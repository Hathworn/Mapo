; ModuleID = '../data/hip_kernels/3718/4/main.cu'
source_filename = "../data/hip_kernels/3718/4/main.cu"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
target triple = "amdgcn-amd-amdhsa"

%struct.texture = type { %struct.textureReference }
%struct.textureReference = type { i32, i32, i32, [3 x i32], %struct.hipChannelFormatDesc, i32, i32, i32, float, float, float, %struct.__hip_texture*, i32, i32, [7 x i32], i32 }
%struct.hipChannelFormatDesc = type { i32, i32, i32, i32, i32 }
%struct.__hip_texture = type opaque
%struct.texture.0 = type { %struct.textureReference }

@tcExpData = protected local_unnamed_addr addrspace(1) externally_initialized global %struct.texture undef, align 8
@tfG = protected local_unnamed_addr addrspace(1) externally_initialized global %struct.texture.0 undef, align 8

; Function Attrs: argmemonly mustprogress nofree norecurse nosync nounwind willreturn
define protected amdgpu_kernel void @_Z16euler_zxz_to_matPfS_i(float addrspace(1)* nocapture readonly %0, float addrspace(1)* nocapture writeonly %1, i32 %2) local_unnamed_addr #0 {
  %4 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %5 = tail call align 4 dereferenceable(64) i8 addrspace(4)* @llvm.amdgcn.dispatch.ptr()
  %6 = getelementptr i8, i8 addrspace(4)* %5, i64 4
  %7 = bitcast i8 addrspace(4)* %6 to i16 addrspace(4)*
  %8 = load i16, i16 addrspace(4)* %7, align 4, !range !4, !invariant.load !5
  %9 = zext i16 %8 to i32
  %10 = mul i32 %4, %9
  %11 = tail call i32 @llvm.amdgcn.workitem.id.x(), !range !6
  %12 = add i32 %10, %11
  %13 = icmp slt i32 %12, %2
  br i1 %13, label %14, label %905

14:                                               ; preds = %3
  %15 = mul nsw i32 %12, 3
  %16 = sext i32 %15 to i64
  %17 = getelementptr inbounds float, float addrspace(1)* %0, i64 %16
  %18 = load float, float addrspace(1)* %17, align 4, !tbaa !7, !amdgpu.noclobber !5
  %19 = tail call float @llvm.fabs.f32(float %18)
  %20 = fcmp olt float %19, 1.310720e+05
  br i1 %20, label %21, label %29

21:                                               ; preds = %14
  %22 = fmul float %19, 0x3FE45F3060000000
  %23 = tail call float @llvm.rint.f32(float %22)
  %24 = tail call float @llvm.fma.f32(float %23, float 0xBFF921FB40000000, float %19)
  %25 = tail call float @llvm.fma.f32(float %23, float 0xBE74442D00000000, float %24)
  %26 = tail call float @llvm.fma.f32(float %23, float 0xBCF8469880000000, float %25)
  %27 = fptosi float %23 to i32
  %28 = bitcast float %19 to i32
  br label %135

29:                                               ; preds = %14
  %30 = bitcast float %19 to i32
  %31 = lshr i32 %30, 23
  %32 = and i32 %30, 8388607
  %33 = or i32 %32, 8388608
  %34 = zext i32 %33 to i64
  %35 = mul nuw nsw i64 %34, 4266746795
  %36 = trunc i64 %35 to i32
  %37 = lshr i64 %35, 32
  %38 = mul nuw nsw i64 %34, 1011060801
  %39 = add nuw nsw i64 %37, %38
  %40 = trunc i64 %39 to i32
  %41 = lshr i64 %39, 32
  %42 = mul nuw nsw i64 %34, 3680671129
  %43 = add nuw nsw i64 %41, %42
  %44 = trunc i64 %43 to i32
  %45 = lshr i64 %43, 32
  %46 = mul nuw nsw i64 %34, 4113882560
  %47 = add nuw nsw i64 %45, %46
  %48 = trunc i64 %47 to i32
  %49 = lshr i64 %47, 32
  %50 = mul nuw nsw i64 %34, 4230436817
  %51 = add nuw nsw i64 %49, %50
  %52 = trunc i64 %51 to i32
  %53 = lshr i64 %51, 32
  %54 = mul nuw nsw i64 %34, 1313084713
  %55 = add nuw nsw i64 %53, %54
  %56 = trunc i64 %55 to i32
  %57 = lshr i64 %55, 32
  %58 = mul nuw nsw i64 %34, 2734261102
  %59 = add nuw nsw i64 %57, %58
  %60 = trunc i64 %59 to i32
  %61 = lshr i64 %59, 32
  %62 = trunc i64 %61 to i32
  %63 = add nsw i32 %31, -120
  %64 = icmp ugt i32 %63, 63
  %65 = select i1 %64, i32 %56, i32 %62
  %66 = select i1 %64, i32 %52, i32 %60
  %67 = select i1 %64, i32 %48, i32 %56
  %68 = select i1 %64, i32 %44, i32 %52
  %69 = select i1 %64, i32 %40, i32 %48
  %70 = select i1 %64, i32 %36, i32 %44
  %71 = select i1 %64, i32 -64, i32 0
  %72 = add nsw i32 %71, %63
  %73 = icmp ugt i32 %72, 31
  %74 = select i1 %73, i32 %66, i32 %65
  %75 = select i1 %73, i32 %67, i32 %66
  %76 = select i1 %73, i32 %68, i32 %67
  %77 = select i1 %73, i32 %69, i32 %68
  %78 = select i1 %73, i32 %70, i32 %69
  %79 = select i1 %73, i32 -32, i32 0
  %80 = add nsw i32 %79, %72
  %81 = icmp ugt i32 %80, 31
  %82 = select i1 %81, i32 %75, i32 %74
  %83 = select i1 %81, i32 %76, i32 %75
  %84 = select i1 %81, i32 %77, i32 %76
  %85 = select i1 %81, i32 %78, i32 %77
  %86 = select i1 %81, i32 -32, i32 0
  %87 = add nsw i32 %86, %80
  %88 = icmp eq i32 %87, 0
  %89 = sub nsw i32 32, %87
  %90 = tail call i32 @llvm.fshr.i32(i32 %82, i32 %83, i32 %89)
  %91 = tail call i32 @llvm.fshr.i32(i32 %83, i32 %84, i32 %89)
  %92 = tail call i32 @llvm.fshr.i32(i32 %84, i32 %85, i32 %89)
  %93 = select i1 %88, i32 %82, i32 %90
  %94 = select i1 %88, i32 %83, i32 %91
  %95 = select i1 %88, i32 %84, i32 %92
  %96 = lshr i32 %93, 29
  %97 = tail call i32 @llvm.fshl.i32(i32 %93, i32 %94, i32 2)
  %98 = tail call i32 @llvm.fshl.i32(i32 %94, i32 %95, i32 2)
  %99 = tail call i32 @llvm.fshl.i32(i32 %95, i32 %85, i32 2)
  %100 = and i32 %96, 1
  %101 = sub nsw i32 0, %100
  %102 = shl i32 %96, 31
  %103 = xor i32 %97, %101
  %104 = xor i32 %98, %101
  %105 = xor i32 %99, %101
  %106 = tail call i32 @llvm.ctlz.i32(i32 %103, i1 false), !range !11
  %107 = sub nsw i32 31, %106
  %108 = tail call i32 @llvm.fshr.i32(i32 %103, i32 %104, i32 %107)
  %109 = tail call i32 @llvm.fshr.i32(i32 %104, i32 %105, i32 %107)
  %110 = shl nuw nsw i32 %106, 23
  %111 = sub nuw nsw i32 1056964608, %110
  %112 = lshr i32 %108, 9
  %113 = or i32 %112, %111
  %114 = or i32 %113, %102
  %115 = bitcast i32 %114 to float
  %116 = tail call i32 @llvm.fshl.i32(i32 %108, i32 %109, i32 23)
  %117 = tail call i32 @llvm.ctlz.i32(i32 %116, i1 false), !range !11
  %118 = fmul float %115, 0x3FF921FB40000000
  %119 = add nuw nsw i32 %117, %106
  %120 = shl nuw nsw i32 %119, 23
  %121 = sub nuw nsw i32 855638016, %120
  %122 = sub nsw i32 31, %117
  %123 = tail call i32 @llvm.fshr.i32(i32 %116, i32 %109, i32 %122)
  %124 = lshr i32 %123, 9
  %125 = or i32 %121, %124
  %126 = or i32 %125, %102
  %127 = bitcast i32 %126 to float
  %128 = fneg float %118
  %129 = tail call float @llvm.fma.f32(float %115, float 0x3FF921FB40000000, float %128)
  %130 = tail call float @llvm.fma.f32(float %115, float 0x3E74442D00000000, float %129)
  %131 = tail call float @llvm.fma.f32(float %127, float 0x3FF921FB40000000, float %130)
  %132 = fadd float %118, %131
  %133 = lshr i32 %93, 30
  %134 = add nuw nsw i32 %100, %133
  br label %135

135:                                              ; preds = %21, %29
  %136 = phi i32 [ %28, %21 ], [ %30, %29 ]
  %137 = phi float [ %26, %21 ], [ %132, %29 ]
  %138 = phi i32 [ %27, %21 ], [ %134, %29 ]
  %139 = fmul float %137, %137
  %140 = tail call float @llvm.fmuladd.f32(float %139, float 0xBF29833040000000, float 0x3F81103880000000)
  %141 = tail call float @llvm.fmuladd.f32(float %139, float %140, float 0xBFC55553A0000000)
  %142 = fmul float %139, %141
  %143 = tail call float @llvm.fmuladd.f32(float %137, float %142, float %137)
  %144 = tail call float @llvm.fmuladd.f32(float %139, float 0x3EFAEA6680000000, float 0xBF56C9E760000000)
  %145 = tail call float @llvm.fmuladd.f32(float %139, float %144, float 0x3FA5557EE0000000)
  %146 = tail call float @llvm.fmuladd.f32(float %139, float %145, float 0xBFE0000080000000)
  %147 = tail call float @llvm.fmuladd.f32(float %139, float %146, float 1.000000e+00)
  %148 = and i32 %138, 1
  %149 = icmp eq i32 %148, 0
  %150 = select i1 %149, float %143, float %147
  %151 = bitcast float %150 to i32
  %152 = shl i32 %138, 30
  %153 = and i32 %152, -2147483648
  %154 = bitcast float %18 to i32
  %155 = xor i32 %136, %154
  %156 = xor i32 %155, %153
  %157 = xor i32 %156, %151
  %158 = bitcast i32 %157 to float
  %159 = tail call i1 @llvm.amdgcn.class.f32(float %19, i32 504)
  %160 = select i1 %159, float %158, float 0x7FF8000000000000
  %161 = add nsw i32 %15, 1
  %162 = sext i32 %161 to i64
  %163 = getelementptr inbounds float, float addrspace(1)* %0, i64 %162
  %164 = load float, float addrspace(1)* %163, align 4, !tbaa !7, !amdgpu.noclobber !5
  %165 = tail call float @llvm.fabs.f32(float %164)
  %166 = fcmp olt float %165, 1.310720e+05
  br i1 %166, label %167, label %175

167:                                              ; preds = %135
  %168 = fmul float %165, 0x3FE45F3060000000
  %169 = tail call float @llvm.rint.f32(float %168)
  %170 = tail call float @llvm.fma.f32(float %169, float 0xBFF921FB40000000, float %165)
  %171 = tail call float @llvm.fma.f32(float %169, float 0xBE74442D00000000, float %170)
  %172 = tail call float @llvm.fma.f32(float %169, float 0xBCF8469880000000, float %171)
  %173 = fptosi float %169 to i32
  %174 = bitcast float %165 to i32
  br label %281

175:                                              ; preds = %135
  %176 = bitcast float %165 to i32
  %177 = lshr i32 %176, 23
  %178 = and i32 %176, 8388607
  %179 = or i32 %178, 8388608
  %180 = zext i32 %179 to i64
  %181 = mul nuw nsw i64 %180, 4266746795
  %182 = trunc i64 %181 to i32
  %183 = lshr i64 %181, 32
  %184 = mul nuw nsw i64 %180, 1011060801
  %185 = add nuw nsw i64 %183, %184
  %186 = trunc i64 %185 to i32
  %187 = lshr i64 %185, 32
  %188 = mul nuw nsw i64 %180, 3680671129
  %189 = add nuw nsw i64 %187, %188
  %190 = trunc i64 %189 to i32
  %191 = lshr i64 %189, 32
  %192 = mul nuw nsw i64 %180, 4113882560
  %193 = add nuw nsw i64 %191, %192
  %194 = trunc i64 %193 to i32
  %195 = lshr i64 %193, 32
  %196 = mul nuw nsw i64 %180, 4230436817
  %197 = add nuw nsw i64 %195, %196
  %198 = trunc i64 %197 to i32
  %199 = lshr i64 %197, 32
  %200 = mul nuw nsw i64 %180, 1313084713
  %201 = add nuw nsw i64 %199, %200
  %202 = trunc i64 %201 to i32
  %203 = lshr i64 %201, 32
  %204 = mul nuw nsw i64 %180, 2734261102
  %205 = add nuw nsw i64 %203, %204
  %206 = trunc i64 %205 to i32
  %207 = lshr i64 %205, 32
  %208 = trunc i64 %207 to i32
  %209 = add nsw i32 %177, -120
  %210 = icmp ugt i32 %209, 63
  %211 = select i1 %210, i32 %202, i32 %208
  %212 = select i1 %210, i32 %198, i32 %206
  %213 = select i1 %210, i32 %194, i32 %202
  %214 = select i1 %210, i32 %190, i32 %198
  %215 = select i1 %210, i32 %186, i32 %194
  %216 = select i1 %210, i32 %182, i32 %190
  %217 = select i1 %210, i32 -64, i32 0
  %218 = add nsw i32 %217, %209
  %219 = icmp ugt i32 %218, 31
  %220 = select i1 %219, i32 %212, i32 %211
  %221 = select i1 %219, i32 %213, i32 %212
  %222 = select i1 %219, i32 %214, i32 %213
  %223 = select i1 %219, i32 %215, i32 %214
  %224 = select i1 %219, i32 %216, i32 %215
  %225 = select i1 %219, i32 -32, i32 0
  %226 = add nsw i32 %225, %218
  %227 = icmp ugt i32 %226, 31
  %228 = select i1 %227, i32 %221, i32 %220
  %229 = select i1 %227, i32 %222, i32 %221
  %230 = select i1 %227, i32 %223, i32 %222
  %231 = select i1 %227, i32 %224, i32 %223
  %232 = select i1 %227, i32 -32, i32 0
  %233 = add nsw i32 %232, %226
  %234 = icmp eq i32 %233, 0
  %235 = sub nsw i32 32, %233
  %236 = tail call i32 @llvm.fshr.i32(i32 %228, i32 %229, i32 %235)
  %237 = tail call i32 @llvm.fshr.i32(i32 %229, i32 %230, i32 %235)
  %238 = tail call i32 @llvm.fshr.i32(i32 %230, i32 %231, i32 %235)
  %239 = select i1 %234, i32 %228, i32 %236
  %240 = select i1 %234, i32 %229, i32 %237
  %241 = select i1 %234, i32 %230, i32 %238
  %242 = lshr i32 %239, 29
  %243 = tail call i32 @llvm.fshl.i32(i32 %239, i32 %240, i32 2)
  %244 = tail call i32 @llvm.fshl.i32(i32 %240, i32 %241, i32 2)
  %245 = tail call i32 @llvm.fshl.i32(i32 %241, i32 %231, i32 2)
  %246 = and i32 %242, 1
  %247 = sub nsw i32 0, %246
  %248 = shl i32 %242, 31
  %249 = xor i32 %243, %247
  %250 = xor i32 %244, %247
  %251 = xor i32 %245, %247
  %252 = tail call i32 @llvm.ctlz.i32(i32 %249, i1 false), !range !11
  %253 = sub nsw i32 31, %252
  %254 = tail call i32 @llvm.fshr.i32(i32 %249, i32 %250, i32 %253)
  %255 = tail call i32 @llvm.fshr.i32(i32 %250, i32 %251, i32 %253)
  %256 = shl nuw nsw i32 %252, 23
  %257 = sub nuw nsw i32 1056964608, %256
  %258 = lshr i32 %254, 9
  %259 = or i32 %258, %257
  %260 = or i32 %259, %248
  %261 = bitcast i32 %260 to float
  %262 = tail call i32 @llvm.fshl.i32(i32 %254, i32 %255, i32 23)
  %263 = tail call i32 @llvm.ctlz.i32(i32 %262, i1 false), !range !11
  %264 = fmul float %261, 0x3FF921FB40000000
  %265 = add nuw nsw i32 %263, %252
  %266 = shl nuw nsw i32 %265, 23
  %267 = sub nuw nsw i32 855638016, %266
  %268 = sub nsw i32 31, %263
  %269 = tail call i32 @llvm.fshr.i32(i32 %262, i32 %255, i32 %268)
  %270 = lshr i32 %269, 9
  %271 = or i32 %267, %270
  %272 = or i32 %271, %248
  %273 = bitcast i32 %272 to float
  %274 = fneg float %264
  %275 = tail call float @llvm.fma.f32(float %261, float 0x3FF921FB40000000, float %274)
  %276 = tail call float @llvm.fma.f32(float %261, float 0x3E74442D00000000, float %275)
  %277 = tail call float @llvm.fma.f32(float %273, float 0x3FF921FB40000000, float %276)
  %278 = fadd float %264, %277
  %279 = lshr i32 %239, 30
  %280 = add nuw nsw i32 %246, %279
  br label %281

281:                                              ; preds = %167, %175
  %282 = phi i32 [ %174, %167 ], [ %176, %175 ]
  %283 = phi float [ %172, %167 ], [ %278, %175 ]
  %284 = phi i32 [ %173, %167 ], [ %280, %175 ]
  %285 = fmul float %283, %283
  %286 = tail call float @llvm.fmuladd.f32(float %285, float 0xBF29833040000000, float 0x3F81103880000000)
  %287 = tail call float @llvm.fmuladd.f32(float %285, float %286, float 0xBFC55553A0000000)
  %288 = fmul float %285, %287
  %289 = tail call float @llvm.fmuladd.f32(float %283, float %288, float %283)
  %290 = tail call float @llvm.fmuladd.f32(float %285, float 0x3EFAEA6680000000, float 0xBF56C9E760000000)
  %291 = tail call float @llvm.fmuladd.f32(float %285, float %290, float 0x3FA5557EE0000000)
  %292 = tail call float @llvm.fmuladd.f32(float %285, float %291, float 0xBFE0000080000000)
  %293 = tail call float @llvm.fmuladd.f32(float %285, float %292, float 1.000000e+00)
  %294 = and i32 %284, 1
  %295 = icmp eq i32 %294, 0
  %296 = select i1 %295, float %289, float %293
  %297 = bitcast float %296 to i32
  %298 = shl i32 %284, 30
  %299 = and i32 %298, -2147483648
  %300 = bitcast float %164 to i32
  %301 = xor i32 %282, %300
  %302 = xor i32 %301, %299
  %303 = xor i32 %302, %297
  %304 = bitcast i32 %303 to float
  %305 = tail call i1 @llvm.amdgcn.class.f32(float %165, i32 504)
  %306 = select i1 %305, float %304, float 0x7FF8000000000000
  %307 = add nsw i32 %15, 2
  %308 = sext i32 %307 to i64
  %309 = getelementptr inbounds float, float addrspace(1)* %0, i64 %308
  %310 = load float, float addrspace(1)* %309, align 4, !tbaa !7, !amdgpu.noclobber !5
  %311 = tail call float @llvm.fabs.f32(float %310)
  %312 = fcmp olt float %311, 1.310720e+05
  br i1 %312, label %313, label %321

313:                                              ; preds = %281
  %314 = fmul float %311, 0x3FE45F3060000000
  %315 = tail call float @llvm.rint.f32(float %314)
  %316 = tail call float @llvm.fma.f32(float %315, float 0xBFF921FB40000000, float %311)
  %317 = tail call float @llvm.fma.f32(float %315, float 0xBE74442D00000000, float %316)
  %318 = tail call float @llvm.fma.f32(float %315, float 0xBCF8469880000000, float %317)
  %319 = fptosi float %315 to i32
  %320 = bitcast float %311 to i32
  br label %427

321:                                              ; preds = %281
  %322 = bitcast float %311 to i32
  %323 = lshr i32 %322, 23
  %324 = and i32 %322, 8388607
  %325 = or i32 %324, 8388608
  %326 = zext i32 %325 to i64
  %327 = mul nuw nsw i64 %326, 4266746795
  %328 = trunc i64 %327 to i32
  %329 = lshr i64 %327, 32
  %330 = mul nuw nsw i64 %326, 1011060801
  %331 = add nuw nsw i64 %329, %330
  %332 = trunc i64 %331 to i32
  %333 = lshr i64 %331, 32
  %334 = mul nuw nsw i64 %326, 3680671129
  %335 = add nuw nsw i64 %333, %334
  %336 = trunc i64 %335 to i32
  %337 = lshr i64 %335, 32
  %338 = mul nuw nsw i64 %326, 4113882560
  %339 = add nuw nsw i64 %337, %338
  %340 = trunc i64 %339 to i32
  %341 = lshr i64 %339, 32
  %342 = mul nuw nsw i64 %326, 4230436817
  %343 = add nuw nsw i64 %341, %342
  %344 = trunc i64 %343 to i32
  %345 = lshr i64 %343, 32
  %346 = mul nuw nsw i64 %326, 1313084713
  %347 = add nuw nsw i64 %345, %346
  %348 = trunc i64 %347 to i32
  %349 = lshr i64 %347, 32
  %350 = mul nuw nsw i64 %326, 2734261102
  %351 = add nuw nsw i64 %349, %350
  %352 = trunc i64 %351 to i32
  %353 = lshr i64 %351, 32
  %354 = trunc i64 %353 to i32
  %355 = add nsw i32 %323, -120
  %356 = icmp ugt i32 %355, 63
  %357 = select i1 %356, i32 %348, i32 %354
  %358 = select i1 %356, i32 %344, i32 %352
  %359 = select i1 %356, i32 %340, i32 %348
  %360 = select i1 %356, i32 %336, i32 %344
  %361 = select i1 %356, i32 %332, i32 %340
  %362 = select i1 %356, i32 %328, i32 %336
  %363 = select i1 %356, i32 -64, i32 0
  %364 = add nsw i32 %363, %355
  %365 = icmp ugt i32 %364, 31
  %366 = select i1 %365, i32 %358, i32 %357
  %367 = select i1 %365, i32 %359, i32 %358
  %368 = select i1 %365, i32 %360, i32 %359
  %369 = select i1 %365, i32 %361, i32 %360
  %370 = select i1 %365, i32 %362, i32 %361
  %371 = select i1 %365, i32 -32, i32 0
  %372 = add nsw i32 %371, %364
  %373 = icmp ugt i32 %372, 31
  %374 = select i1 %373, i32 %367, i32 %366
  %375 = select i1 %373, i32 %368, i32 %367
  %376 = select i1 %373, i32 %369, i32 %368
  %377 = select i1 %373, i32 %370, i32 %369
  %378 = select i1 %373, i32 -32, i32 0
  %379 = add nsw i32 %378, %372
  %380 = icmp eq i32 %379, 0
  %381 = sub nsw i32 32, %379
  %382 = tail call i32 @llvm.fshr.i32(i32 %374, i32 %375, i32 %381)
  %383 = tail call i32 @llvm.fshr.i32(i32 %375, i32 %376, i32 %381)
  %384 = tail call i32 @llvm.fshr.i32(i32 %376, i32 %377, i32 %381)
  %385 = select i1 %380, i32 %374, i32 %382
  %386 = select i1 %380, i32 %375, i32 %383
  %387 = select i1 %380, i32 %376, i32 %384
  %388 = lshr i32 %385, 29
  %389 = tail call i32 @llvm.fshl.i32(i32 %385, i32 %386, i32 2)
  %390 = tail call i32 @llvm.fshl.i32(i32 %386, i32 %387, i32 2)
  %391 = tail call i32 @llvm.fshl.i32(i32 %387, i32 %377, i32 2)
  %392 = and i32 %388, 1
  %393 = sub nsw i32 0, %392
  %394 = shl i32 %388, 31
  %395 = xor i32 %389, %393
  %396 = xor i32 %390, %393
  %397 = xor i32 %391, %393
  %398 = tail call i32 @llvm.ctlz.i32(i32 %395, i1 false), !range !11
  %399 = sub nsw i32 31, %398
  %400 = tail call i32 @llvm.fshr.i32(i32 %395, i32 %396, i32 %399)
  %401 = tail call i32 @llvm.fshr.i32(i32 %396, i32 %397, i32 %399)
  %402 = shl nuw nsw i32 %398, 23
  %403 = sub nuw nsw i32 1056964608, %402
  %404 = lshr i32 %400, 9
  %405 = or i32 %404, %403
  %406 = or i32 %405, %394
  %407 = bitcast i32 %406 to float
  %408 = tail call i32 @llvm.fshl.i32(i32 %400, i32 %401, i32 23)
  %409 = tail call i32 @llvm.ctlz.i32(i32 %408, i1 false), !range !11
  %410 = fmul float %407, 0x3FF921FB40000000
  %411 = add nuw nsw i32 %409, %398
  %412 = shl nuw nsw i32 %411, 23
  %413 = sub nuw nsw i32 855638016, %412
  %414 = sub nsw i32 31, %409
  %415 = tail call i32 @llvm.fshr.i32(i32 %408, i32 %401, i32 %414)
  %416 = lshr i32 %415, 9
  %417 = or i32 %413, %416
  %418 = or i32 %417, %394
  %419 = bitcast i32 %418 to float
  %420 = fneg float %410
  %421 = tail call float @llvm.fma.f32(float %407, float 0x3FF921FB40000000, float %420)
  %422 = tail call float @llvm.fma.f32(float %407, float 0x3E74442D00000000, float %421)
  %423 = tail call float @llvm.fma.f32(float %419, float 0x3FF921FB40000000, float %422)
  %424 = fadd float %410, %423
  %425 = lshr i32 %385, 30
  %426 = add nuw nsw i32 %392, %425
  br label %427

427:                                              ; preds = %313, %321
  %428 = phi i32 [ %320, %313 ], [ %322, %321 ]
  %429 = phi float [ %318, %313 ], [ %424, %321 ]
  %430 = phi i32 [ %319, %313 ], [ %426, %321 ]
  %431 = fmul float %429, %429
  %432 = tail call float @llvm.fmuladd.f32(float %431, float 0xBF29833040000000, float 0x3F81103880000000)
  %433 = tail call float @llvm.fmuladd.f32(float %431, float %432, float 0xBFC55553A0000000)
  %434 = fmul float %431, %433
  %435 = tail call float @llvm.fmuladd.f32(float %429, float %434, float %429)
  %436 = tail call float @llvm.fmuladd.f32(float %431, float 0x3EFAEA6680000000, float 0xBF56C9E760000000)
  %437 = tail call float @llvm.fmuladd.f32(float %431, float %436, float 0x3FA5557EE0000000)
  %438 = tail call float @llvm.fmuladd.f32(float %431, float %437, float 0xBFE0000080000000)
  %439 = tail call float @llvm.fmuladd.f32(float %431, float %438, float 1.000000e+00)
  %440 = and i32 %430, 1
  %441 = icmp eq i32 %440, 0
  %442 = select i1 %441, float %435, float %439
  %443 = bitcast float %442 to i32
  %444 = shl i32 %430, 30
  %445 = and i32 %444, -2147483648
  %446 = bitcast float %310 to i32
  %447 = xor i32 %428, %446
  %448 = xor i32 %447, %445
  %449 = xor i32 %448, %443
  %450 = bitcast i32 %449 to float
  %451 = tail call i1 @llvm.amdgcn.class.f32(float %311, i32 504)
  %452 = select i1 %451, float %450, float 0x7FF8000000000000
  br i1 %20, label %453, label %460

453:                                              ; preds = %427
  %454 = fmul float %19, 0x3FE45F3060000000
  %455 = tail call float @llvm.rint.f32(float %454)
  %456 = tail call float @llvm.fma.f32(float %455, float 0xBFF921FB40000000, float %19)
  %457 = tail call float @llvm.fma.f32(float %455, float 0xBE74442D00000000, float %456)
  %458 = tail call float @llvm.fma.f32(float %455, float 0xBCF8469880000000, float %457)
  %459 = fptosi float %455 to i32
  br label %566

460:                                              ; preds = %427
  %461 = bitcast float %19 to i32
  %462 = lshr i32 %461, 23
  %463 = and i32 %461, 8388607
  %464 = or i32 %463, 8388608
  %465 = zext i32 %464 to i64
  %466 = mul nuw nsw i64 %465, 4266746795
  %467 = trunc i64 %466 to i32
  %468 = lshr i64 %466, 32
  %469 = mul nuw nsw i64 %465, 1011060801
  %470 = add nuw nsw i64 %468, %469
  %471 = trunc i64 %470 to i32
  %472 = lshr i64 %470, 32
  %473 = mul nuw nsw i64 %465, 3680671129
  %474 = add nuw nsw i64 %472, %473
  %475 = trunc i64 %474 to i32
  %476 = lshr i64 %474, 32
  %477 = mul nuw nsw i64 %465, 4113882560
  %478 = add nuw nsw i64 %476, %477
  %479 = trunc i64 %478 to i32
  %480 = lshr i64 %478, 32
  %481 = mul nuw nsw i64 %465, 4230436817
  %482 = add nuw nsw i64 %480, %481
  %483 = trunc i64 %482 to i32
  %484 = lshr i64 %482, 32
  %485 = mul nuw nsw i64 %465, 1313084713
  %486 = add nuw nsw i64 %484, %485
  %487 = trunc i64 %486 to i32
  %488 = lshr i64 %486, 32
  %489 = mul nuw nsw i64 %465, 2734261102
  %490 = add nuw nsw i64 %488, %489
  %491 = trunc i64 %490 to i32
  %492 = lshr i64 %490, 32
  %493 = trunc i64 %492 to i32
  %494 = add nsw i32 %462, -120
  %495 = icmp ugt i32 %494, 63
  %496 = select i1 %495, i32 %487, i32 %493
  %497 = select i1 %495, i32 %483, i32 %491
  %498 = select i1 %495, i32 %479, i32 %487
  %499 = select i1 %495, i32 %475, i32 %483
  %500 = select i1 %495, i32 %471, i32 %479
  %501 = select i1 %495, i32 %467, i32 %475
  %502 = select i1 %495, i32 -64, i32 0
  %503 = add nsw i32 %502, %494
  %504 = icmp ugt i32 %503, 31
  %505 = select i1 %504, i32 %497, i32 %496
  %506 = select i1 %504, i32 %498, i32 %497
  %507 = select i1 %504, i32 %499, i32 %498
  %508 = select i1 %504, i32 %500, i32 %499
  %509 = select i1 %504, i32 %501, i32 %500
  %510 = select i1 %504, i32 -32, i32 0
  %511 = add nsw i32 %510, %503
  %512 = icmp ugt i32 %511, 31
  %513 = select i1 %512, i32 %506, i32 %505
  %514 = select i1 %512, i32 %507, i32 %506
  %515 = select i1 %512, i32 %508, i32 %507
  %516 = select i1 %512, i32 %509, i32 %508
  %517 = select i1 %512, i32 -32, i32 0
  %518 = add nsw i32 %517, %511
  %519 = icmp eq i32 %518, 0
  %520 = sub nsw i32 32, %518
  %521 = tail call i32 @llvm.fshr.i32(i32 %513, i32 %514, i32 %520)
  %522 = tail call i32 @llvm.fshr.i32(i32 %514, i32 %515, i32 %520)
  %523 = tail call i32 @llvm.fshr.i32(i32 %515, i32 %516, i32 %520)
  %524 = select i1 %519, i32 %513, i32 %521
  %525 = select i1 %519, i32 %514, i32 %522
  %526 = select i1 %519, i32 %515, i32 %523
  %527 = lshr i32 %524, 29
  %528 = tail call i32 @llvm.fshl.i32(i32 %524, i32 %525, i32 2)
  %529 = tail call i32 @llvm.fshl.i32(i32 %525, i32 %526, i32 2)
  %530 = tail call i32 @llvm.fshl.i32(i32 %526, i32 %516, i32 2)
  %531 = and i32 %527, 1
  %532 = sub nsw i32 0, %531
  %533 = shl i32 %527, 31
  %534 = xor i32 %528, %532
  %535 = xor i32 %529, %532
  %536 = xor i32 %530, %532
  %537 = tail call i32 @llvm.ctlz.i32(i32 %534, i1 false), !range !11
  %538 = sub nsw i32 31, %537
  %539 = tail call i32 @llvm.fshr.i32(i32 %534, i32 %535, i32 %538)
  %540 = tail call i32 @llvm.fshr.i32(i32 %535, i32 %536, i32 %538)
  %541 = shl nuw nsw i32 %537, 23
  %542 = sub nuw nsw i32 1056964608, %541
  %543 = lshr i32 %539, 9
  %544 = or i32 %543, %542
  %545 = or i32 %544, %533
  %546 = bitcast i32 %545 to float
  %547 = tail call i32 @llvm.fshl.i32(i32 %539, i32 %540, i32 23)
  %548 = tail call i32 @llvm.ctlz.i32(i32 %547, i1 false), !range !11
  %549 = fmul float %546, 0x3FF921FB40000000
  %550 = add nuw nsw i32 %548, %537
  %551 = shl nuw nsw i32 %550, 23
  %552 = sub nuw nsw i32 855638016, %551
  %553 = sub nsw i32 31, %548
  %554 = tail call i32 @llvm.fshr.i32(i32 %547, i32 %540, i32 %553)
  %555 = lshr i32 %554, 9
  %556 = or i32 %552, %555
  %557 = or i32 %556, %533
  %558 = bitcast i32 %557 to float
  %559 = fneg float %549
  %560 = tail call float @llvm.fma.f32(float %546, float 0x3FF921FB40000000, float %559)
  %561 = tail call float @llvm.fma.f32(float %546, float 0x3E74442D00000000, float %560)
  %562 = tail call float @llvm.fma.f32(float %558, float 0x3FF921FB40000000, float %561)
  %563 = fadd float %549, %562
  %564 = lshr i32 %524, 30
  %565 = add nuw nsw i32 %531, %564
  br label %566

566:                                              ; preds = %453, %460
  %567 = phi float [ %458, %453 ], [ %563, %460 ]
  %568 = phi i32 [ %459, %453 ], [ %565, %460 ]
  %569 = fmul float %567, %567
  %570 = tail call float @llvm.fmuladd.f32(float %569, float 0xBF29833040000000, float 0x3F81103880000000)
  %571 = tail call float @llvm.fmuladd.f32(float %569, float %570, float 0xBFC55553A0000000)
  %572 = fmul float %569, %571
  %573 = tail call float @llvm.fmuladd.f32(float %567, float %572, float %567)
  %574 = tail call float @llvm.fmuladd.f32(float %569, float 0x3EFAEA6680000000, float 0xBF56C9E760000000)
  %575 = tail call float @llvm.fmuladd.f32(float %569, float %574, float 0x3FA5557EE0000000)
  %576 = tail call float @llvm.fmuladd.f32(float %569, float %575, float 0xBFE0000080000000)
  %577 = tail call float @llvm.fmuladd.f32(float %569, float %576, float 1.000000e+00)
  %578 = fneg float %573
  %579 = and i32 %568, 1
  %580 = icmp eq i32 %579, 0
  %581 = select i1 %580, float %577, float %578
  %582 = bitcast float %581 to i32
  %583 = shl i32 %568, 30
  %584 = and i32 %583, -2147483648
  %585 = xor i32 %584, %582
  %586 = bitcast i32 %585 to float
  %587 = select i1 %159, float %586, float 0x7FF8000000000000
  br i1 %166, label %588, label %595

588:                                              ; preds = %566
  %589 = fmul float %165, 0x3FE45F3060000000
  %590 = tail call float @llvm.rint.f32(float %589)
  %591 = tail call float @llvm.fma.f32(float %590, float 0xBFF921FB40000000, float %165)
  %592 = tail call float @llvm.fma.f32(float %590, float 0xBE74442D00000000, float %591)
  %593 = tail call float @llvm.fma.f32(float %590, float 0xBCF8469880000000, float %592)
  %594 = fptosi float %590 to i32
  br label %701

595:                                              ; preds = %566
  %596 = bitcast float %165 to i32
  %597 = lshr i32 %596, 23
  %598 = and i32 %596, 8388607
  %599 = or i32 %598, 8388608
  %600 = zext i32 %599 to i64
  %601 = mul nuw nsw i64 %600, 4266746795
  %602 = trunc i64 %601 to i32
  %603 = lshr i64 %601, 32
  %604 = mul nuw nsw i64 %600, 1011060801
  %605 = add nuw nsw i64 %603, %604
  %606 = trunc i64 %605 to i32
  %607 = lshr i64 %605, 32
  %608 = mul nuw nsw i64 %600, 3680671129
  %609 = add nuw nsw i64 %607, %608
  %610 = trunc i64 %609 to i32
  %611 = lshr i64 %609, 32
  %612 = mul nuw nsw i64 %600, 4113882560
  %613 = add nuw nsw i64 %611, %612
  %614 = trunc i64 %613 to i32
  %615 = lshr i64 %613, 32
  %616 = mul nuw nsw i64 %600, 4230436817
  %617 = add nuw nsw i64 %615, %616
  %618 = trunc i64 %617 to i32
  %619 = lshr i64 %617, 32
  %620 = mul nuw nsw i64 %600, 1313084713
  %621 = add nuw nsw i64 %619, %620
  %622 = trunc i64 %621 to i32
  %623 = lshr i64 %621, 32
  %624 = mul nuw nsw i64 %600, 2734261102
  %625 = add nuw nsw i64 %623, %624
  %626 = trunc i64 %625 to i32
  %627 = lshr i64 %625, 32
  %628 = trunc i64 %627 to i32
  %629 = add nsw i32 %597, -120
  %630 = icmp ugt i32 %629, 63
  %631 = select i1 %630, i32 %622, i32 %628
  %632 = select i1 %630, i32 %618, i32 %626
  %633 = select i1 %630, i32 %614, i32 %622
  %634 = select i1 %630, i32 %610, i32 %618
  %635 = select i1 %630, i32 %606, i32 %614
  %636 = select i1 %630, i32 %602, i32 %610
  %637 = select i1 %630, i32 -64, i32 0
  %638 = add nsw i32 %637, %629
  %639 = icmp ugt i32 %638, 31
  %640 = select i1 %639, i32 %632, i32 %631
  %641 = select i1 %639, i32 %633, i32 %632
  %642 = select i1 %639, i32 %634, i32 %633
  %643 = select i1 %639, i32 %635, i32 %634
  %644 = select i1 %639, i32 %636, i32 %635
  %645 = select i1 %639, i32 -32, i32 0
  %646 = add nsw i32 %645, %638
  %647 = icmp ugt i32 %646, 31
  %648 = select i1 %647, i32 %641, i32 %640
  %649 = select i1 %647, i32 %642, i32 %641
  %650 = select i1 %647, i32 %643, i32 %642
  %651 = select i1 %647, i32 %644, i32 %643
  %652 = select i1 %647, i32 -32, i32 0
  %653 = add nsw i32 %652, %646
  %654 = icmp eq i32 %653, 0
  %655 = sub nsw i32 32, %653
  %656 = tail call i32 @llvm.fshr.i32(i32 %648, i32 %649, i32 %655)
  %657 = tail call i32 @llvm.fshr.i32(i32 %649, i32 %650, i32 %655)
  %658 = tail call i32 @llvm.fshr.i32(i32 %650, i32 %651, i32 %655)
  %659 = select i1 %654, i32 %648, i32 %656
  %660 = select i1 %654, i32 %649, i32 %657
  %661 = select i1 %654, i32 %650, i32 %658
  %662 = lshr i32 %659, 29
  %663 = tail call i32 @llvm.fshl.i32(i32 %659, i32 %660, i32 2)
  %664 = tail call i32 @llvm.fshl.i32(i32 %660, i32 %661, i32 2)
  %665 = tail call i32 @llvm.fshl.i32(i32 %661, i32 %651, i32 2)
  %666 = and i32 %662, 1
  %667 = sub nsw i32 0, %666
  %668 = shl i32 %662, 31
  %669 = xor i32 %663, %667
  %670 = xor i32 %664, %667
  %671 = xor i32 %665, %667
  %672 = tail call i32 @llvm.ctlz.i32(i32 %669, i1 false), !range !11
  %673 = sub nsw i32 31, %672
  %674 = tail call i32 @llvm.fshr.i32(i32 %669, i32 %670, i32 %673)
  %675 = tail call i32 @llvm.fshr.i32(i32 %670, i32 %671, i32 %673)
  %676 = shl nuw nsw i32 %672, 23
  %677 = sub nuw nsw i32 1056964608, %676
  %678 = lshr i32 %674, 9
  %679 = or i32 %678, %677
  %680 = or i32 %679, %668
  %681 = bitcast i32 %680 to float
  %682 = tail call i32 @llvm.fshl.i32(i32 %674, i32 %675, i32 23)
  %683 = tail call i32 @llvm.ctlz.i32(i32 %682, i1 false), !range !11
  %684 = fmul float %681, 0x3FF921FB40000000
  %685 = add nuw nsw i32 %683, %672
  %686 = shl nuw nsw i32 %685, 23
  %687 = sub nuw nsw i32 855638016, %686
  %688 = sub nsw i32 31, %683
  %689 = tail call i32 @llvm.fshr.i32(i32 %682, i32 %675, i32 %688)
  %690 = lshr i32 %689, 9
  %691 = or i32 %687, %690
  %692 = or i32 %691, %668
  %693 = bitcast i32 %692 to float
  %694 = fneg float %684
  %695 = tail call float @llvm.fma.f32(float %681, float 0x3FF921FB40000000, float %694)
  %696 = tail call float @llvm.fma.f32(float %681, float 0x3E74442D00000000, float %695)
  %697 = tail call float @llvm.fma.f32(float %693, float 0x3FF921FB40000000, float %696)
  %698 = fadd float %684, %697
  %699 = lshr i32 %659, 30
  %700 = add nuw nsw i32 %666, %699
  br label %701

701:                                              ; preds = %588, %595
  %702 = phi float [ %593, %588 ], [ %698, %595 ]
  %703 = phi i32 [ %594, %588 ], [ %700, %595 ]
  %704 = fmul float %702, %702
  %705 = tail call float @llvm.fmuladd.f32(float %704, float 0xBF29833040000000, float 0x3F81103880000000)
  %706 = tail call float @llvm.fmuladd.f32(float %704, float %705, float 0xBFC55553A0000000)
  %707 = fmul float %704, %706
  %708 = tail call float @llvm.fmuladd.f32(float %702, float %707, float %702)
  %709 = tail call float @llvm.fmuladd.f32(float %704, float 0x3EFAEA6680000000, float 0xBF56C9E760000000)
  %710 = tail call float @llvm.fmuladd.f32(float %704, float %709, float 0x3FA5557EE0000000)
  %711 = tail call float @llvm.fmuladd.f32(float %704, float %710, float 0xBFE0000080000000)
  %712 = tail call float @llvm.fmuladd.f32(float %704, float %711, float 1.000000e+00)
  %713 = fneg float %708
  %714 = and i32 %703, 1
  %715 = icmp eq i32 %714, 0
  %716 = select i1 %715, float %712, float %713
  %717 = bitcast float %716 to i32
  %718 = shl i32 %703, 30
  %719 = and i32 %718, -2147483648
  %720 = xor i32 %719, %717
  %721 = bitcast i32 %720 to float
  %722 = select i1 %305, float %721, float 0x7FF8000000000000
  br i1 %312, label %723, label %730

723:                                              ; preds = %701
  %724 = fmul float %311, 0x3FE45F3060000000
  %725 = tail call float @llvm.rint.f32(float %724)
  %726 = tail call float @llvm.fma.f32(float %725, float 0xBFF921FB40000000, float %311)
  %727 = tail call float @llvm.fma.f32(float %725, float 0xBE74442D00000000, float %726)
  %728 = tail call float @llvm.fma.f32(float %725, float 0xBCF8469880000000, float %727)
  %729 = fptosi float %725 to i32
  br label %836

730:                                              ; preds = %701
  %731 = bitcast float %311 to i32
  %732 = lshr i32 %731, 23
  %733 = and i32 %731, 8388607
  %734 = or i32 %733, 8388608
  %735 = zext i32 %734 to i64
  %736 = mul nuw nsw i64 %735, 4266746795
  %737 = trunc i64 %736 to i32
  %738 = lshr i64 %736, 32
  %739 = mul nuw nsw i64 %735, 1011060801
  %740 = add nuw nsw i64 %738, %739
  %741 = trunc i64 %740 to i32
  %742 = lshr i64 %740, 32
  %743 = mul nuw nsw i64 %735, 3680671129
  %744 = add nuw nsw i64 %742, %743
  %745 = trunc i64 %744 to i32
  %746 = lshr i64 %744, 32
  %747 = mul nuw nsw i64 %735, 4113882560
  %748 = add nuw nsw i64 %746, %747
  %749 = trunc i64 %748 to i32
  %750 = lshr i64 %748, 32
  %751 = mul nuw nsw i64 %735, 4230436817
  %752 = add nuw nsw i64 %750, %751
  %753 = trunc i64 %752 to i32
  %754 = lshr i64 %752, 32
  %755 = mul nuw nsw i64 %735, 1313084713
  %756 = add nuw nsw i64 %754, %755
  %757 = trunc i64 %756 to i32
  %758 = lshr i64 %756, 32
  %759 = mul nuw nsw i64 %735, 2734261102
  %760 = add nuw nsw i64 %758, %759
  %761 = trunc i64 %760 to i32
  %762 = lshr i64 %760, 32
  %763 = trunc i64 %762 to i32
  %764 = add nsw i32 %732, -120
  %765 = icmp ugt i32 %764, 63
  %766 = select i1 %765, i32 %757, i32 %763
  %767 = select i1 %765, i32 %753, i32 %761
  %768 = select i1 %765, i32 %749, i32 %757
  %769 = select i1 %765, i32 %745, i32 %753
  %770 = select i1 %765, i32 %741, i32 %749
  %771 = select i1 %765, i32 %737, i32 %745
  %772 = select i1 %765, i32 -64, i32 0
  %773 = add nsw i32 %772, %764
  %774 = icmp ugt i32 %773, 31
  %775 = select i1 %774, i32 %767, i32 %766
  %776 = select i1 %774, i32 %768, i32 %767
  %777 = select i1 %774, i32 %769, i32 %768
  %778 = select i1 %774, i32 %770, i32 %769
  %779 = select i1 %774, i32 %771, i32 %770
  %780 = select i1 %774, i32 -32, i32 0
  %781 = add nsw i32 %780, %773
  %782 = icmp ugt i32 %781, 31
  %783 = select i1 %782, i32 %776, i32 %775
  %784 = select i1 %782, i32 %777, i32 %776
  %785 = select i1 %782, i32 %778, i32 %777
  %786 = select i1 %782, i32 %779, i32 %778
  %787 = select i1 %782, i32 -32, i32 0
  %788 = add nsw i32 %787, %781
  %789 = icmp eq i32 %788, 0
  %790 = sub nsw i32 32, %788
  %791 = tail call i32 @llvm.fshr.i32(i32 %783, i32 %784, i32 %790)
  %792 = tail call i32 @llvm.fshr.i32(i32 %784, i32 %785, i32 %790)
  %793 = tail call i32 @llvm.fshr.i32(i32 %785, i32 %786, i32 %790)
  %794 = select i1 %789, i32 %783, i32 %791
  %795 = select i1 %789, i32 %784, i32 %792
  %796 = select i1 %789, i32 %785, i32 %793
  %797 = lshr i32 %794, 29
  %798 = tail call i32 @llvm.fshl.i32(i32 %794, i32 %795, i32 2)
  %799 = tail call i32 @llvm.fshl.i32(i32 %795, i32 %796, i32 2)
  %800 = tail call i32 @llvm.fshl.i32(i32 %796, i32 %786, i32 2)
  %801 = and i32 %797, 1
  %802 = sub nsw i32 0, %801
  %803 = shl i32 %797, 31
  %804 = xor i32 %798, %802
  %805 = xor i32 %799, %802
  %806 = xor i32 %800, %802
  %807 = tail call i32 @llvm.ctlz.i32(i32 %804, i1 false), !range !11
  %808 = sub nsw i32 31, %807
  %809 = tail call i32 @llvm.fshr.i32(i32 %804, i32 %805, i32 %808)
  %810 = tail call i32 @llvm.fshr.i32(i32 %805, i32 %806, i32 %808)
  %811 = shl nuw nsw i32 %807, 23
  %812 = sub nuw nsw i32 1056964608, %811
  %813 = lshr i32 %809, 9
  %814 = or i32 %813, %812
  %815 = or i32 %814, %803
  %816 = bitcast i32 %815 to float
  %817 = tail call i32 @llvm.fshl.i32(i32 %809, i32 %810, i32 23)
  %818 = tail call i32 @llvm.ctlz.i32(i32 %817, i1 false), !range !11
  %819 = fmul float %816, 0x3FF921FB40000000
  %820 = add nuw nsw i32 %818, %807
  %821 = shl nuw nsw i32 %820, 23
  %822 = sub nuw nsw i32 855638016, %821
  %823 = sub nsw i32 31, %818
  %824 = tail call i32 @llvm.fshr.i32(i32 %817, i32 %810, i32 %823)
  %825 = lshr i32 %824, 9
  %826 = or i32 %822, %825
  %827 = or i32 %826, %803
  %828 = bitcast i32 %827 to float
  %829 = fneg float %819
  %830 = tail call float @llvm.fma.f32(float %816, float 0x3FF921FB40000000, float %829)
  %831 = tail call float @llvm.fma.f32(float %816, float 0x3E74442D00000000, float %830)
  %832 = tail call float @llvm.fma.f32(float %828, float 0x3FF921FB40000000, float %831)
  %833 = fadd float %819, %832
  %834 = lshr i32 %794, 30
  %835 = add nuw nsw i32 %801, %834
  br label %836

836:                                              ; preds = %723, %730
  %837 = phi float [ %728, %723 ], [ %833, %730 ]
  %838 = phi i32 [ %729, %723 ], [ %835, %730 ]
  %839 = fmul float %837, %837
  %840 = tail call float @llvm.fmuladd.f32(float %839, float 0xBF29833040000000, float 0x3F81103880000000)
  %841 = tail call float @llvm.fmuladd.f32(float %839, float %840, float 0xBFC55553A0000000)
  %842 = fmul float %839, %841
  %843 = tail call float @llvm.fmuladd.f32(float %837, float %842, float %837)
  %844 = tail call float @llvm.fmuladd.f32(float %839, float 0x3EFAEA6680000000, float 0xBF56C9E760000000)
  %845 = tail call float @llvm.fmuladd.f32(float %839, float %844, float 0x3FA5557EE0000000)
  %846 = tail call float @llvm.fmuladd.f32(float %839, float %845, float 0xBFE0000080000000)
  %847 = tail call float @llvm.fmuladd.f32(float %839, float %846, float 1.000000e+00)
  %848 = fneg float %843
  %849 = and i32 %838, 1
  %850 = icmp eq i32 %849, 0
  %851 = select i1 %850, float %847, float %848
  %852 = bitcast float %851 to i32
  %853 = shl i32 %838, 30
  %854 = and i32 %853, -2147483648
  %855 = xor i32 %854, %852
  %856 = bitcast i32 %855 to float
  %857 = select i1 %451, float %856, float 0x7FF8000000000000
  %858 = fmul contract float %587, %857
  %859 = fmul contract float %160, %722
  %860 = fmul contract float %452, %859
  %861 = fsub contract float %858, %860
  %862 = mul nsw i32 %12, 9
  %863 = sext i32 %862 to i64
  %864 = getelementptr inbounds float, float addrspace(1)* %1, i64 %863
  store float %861, float addrspace(1)* %864, align 4, !tbaa !7
  %865 = fneg contract float %587
  %866 = fmul contract float %452, %865
  %867 = fmul contract float %722, %857
  %868 = fmul contract float %160, %867
  %869 = fsub contract float %866, %868
  %870 = add nsw i32 %862, 1
  %871 = sext i32 %870 to i64
  %872 = getelementptr inbounds float, float addrspace(1)* %1, i64 %871
  store float %869, float addrspace(1)* %872, align 4, !tbaa !7
  %873 = fmul contract float %160, %306
  %874 = add nsw i32 %862, 2
  %875 = sext i32 %874 to i64
  %876 = getelementptr inbounds float, float addrspace(1)* %1, i64 %875
  store float %873, float addrspace(1)* %876, align 4, !tbaa !7
  %877 = fmul contract float %160, %857
  %878 = fmul contract float %587, %722
  %879 = fmul contract float %452, %878
  %880 = fadd contract float %879, %877
  %881 = add nsw i32 %862, 3
  %882 = sext i32 %881 to i64
  %883 = getelementptr inbounds float, float addrspace(1)* %1, i64 %882
  store float %880, float addrspace(1)* %883, align 4, !tbaa !7
  %884 = fmul contract float %878, %857
  %885 = fmul contract float %160, %452
  %886 = fsub contract float %884, %885
  %887 = add nsw i32 %862, 4
  %888 = sext i32 %887 to i64
  %889 = getelementptr inbounds float, float addrspace(1)* %1, i64 %888
  store float %886, float addrspace(1)* %889, align 4, !tbaa !7
  %890 = fmul contract float %306, %865
  %891 = add nsw i32 %862, 5
  %892 = sext i32 %891 to i64
  %893 = getelementptr inbounds float, float addrspace(1)* %1, i64 %892
  store float %890, float addrspace(1)* %893, align 4, !tbaa !7
  %894 = fmul contract float %306, %452
  %895 = add nsw i32 %862, 6
  %896 = sext i32 %895 to i64
  %897 = getelementptr inbounds float, float addrspace(1)* %1, i64 %896
  store float %894, float addrspace(1)* %897, align 4, !tbaa !7
  %898 = fmul contract float %306, %857
  %899 = add nsw i32 %862, 7
  %900 = sext i32 %899 to i64
  %901 = getelementptr inbounds float, float addrspace(1)* %1, i64 %900
  store float %898, float addrspace(1)* %901, align 4, !tbaa !7
  %902 = add nsw i32 %862, 8
  %903 = sext i32 %902 to i64
  %904 = getelementptr inbounds float, float addrspace(1)* %1, i64 %903
  store float %722, float addrspace(1)* %904, align 4, !tbaa !7
  br label %905

905:                                              ; preds = %836, %3
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.fabs.f32(float) #1

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i1 @llvm.amdgcn.class.f32(float, i32) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.fmuladd.f32(float, float, float) #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.fshr.i32(i32, i32, i32) #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.fshl.i32(i32, i32, i32) #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.ctlz.i32(i32, i1 immarg) #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.rint.f32(float) #1

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.amdgcn.workitem.id.x() #2

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare align 4 i8 addrspace(4)* @llvm.amdgcn.dispatch.ptr() #2

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.amdgcn.workgroup.id.x() #2

attributes #0 = { argmemonly mustprogress nofree norecurse nosync nounwind willreturn "amdgpu-flat-work-group-size"="1,256" "frame-pointer"="none" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="gfx906" "target-features"="+16-bit-insts,+ci-insts,+dl-insts,+dot1-insts,+dot2-insts,+dot7-insts,+dpp,+flat-address-space,+gfx8-insts,+gfx9-insts,+s-memrealtime,+s-memtime-inst,+sramecc" "uniform-work-group-size"="true" }
attributes #1 = { mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { mustprogress nofree nosync nounwind readnone speculatable willreturn }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 15.0.0 (http://10.15.3.7/dcutoolkit/driverruntime/llvm-project.git 340750feeda88c9c2ce8ad481b11d9aa7f033d39)"}
!4 = !{i16 1, i16 1025}
!5 = !{}
!6 = !{i32 0, i32 1024}
!7 = !{!8, !8, i64 0}
!8 = !{!"float", !9, i64 0}
!9 = !{!"omnipotent char", !10, i64 0}
!10 = !{!"Simple C++ TBAA"}
!11 = !{i32 0, i32 33}
