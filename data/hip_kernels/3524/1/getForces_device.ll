; ModuleID = '../data/hip_kernels/3524/1/main.cu'
source_filename = "../data/hip_kernels/3524/1/main.cu"
target datalayout = "e-p:64:64-p1:64:64-p2:32:32-p3:32:32-p4:64:64-p5:32:32-p6:32:32-i64:64-v16:16-v24:32-v32:32-v48:64-v96:128-v192:256-v256:256-v512:512-v1024:1024-v2048:2048-n32:64-S32-A5-G1-ni:7"
target triple = "amdgcn-amd-amdhsa"

%struct.HIP_vector_type.0 = type { %struct.HIP_vector_base.1 }
%struct.HIP_vector_base.1 = type { %union.anon.2 }
%union.anon.2 = type { <4 x float> }
%struct.HIP_vector_type = type { %struct.HIP_vector_base }
%struct.HIP_vector_base = type { %union.anon }
%union.anon = type { %"struct.HIP_vector_base<float, 3>::Native_vec_" }
%"struct.HIP_vector_base<float, 3>::Native_vec_" = type { [3 x float] }

@_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos = internal unnamed_addr addrspace(3) global [256 x %struct.HIP_vector_type.0] undef, align 16

; Function Attrs: convergent mustprogress norecurse nounwind
define protected amdgpu_kernel void @_Z9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEii(%struct.HIP_vector_type.0 addrspace(1)* nocapture readonly %0, %struct.HIP_vector_type addrspace(1)* nocapture writeonly %1, i32 %2, i32 %3) local_unnamed_addr #0 {
  %5 = tail call i32 @llvm.amdgcn.workitem.id.x(), !range !4
  %6 = tail call align 4 dereferenceable(64) i8 addrspace(4)* @llvm.amdgcn.dispatch.ptr()
  %7 = getelementptr i8, i8 addrspace(4)* %6, i64 4
  %8 = bitcast i8 addrspace(4)* %7 to i16 addrspace(4)*
  %9 = load i16, i16 addrspace(4)* %8, align 4, !range !5, !invariant.load !6
  %10 = zext i16 %9 to i32
  %11 = getelementptr inbounds i8, i8 addrspace(4)* %6, i64 12
  %12 = bitcast i8 addrspace(4)* %11 to i32 addrspace(4)*
  %13 = load i32, i32 addrspace(4)* %12, align 4, !tbaa !7
  %14 = tail call i32 @llvm.amdgcn.workgroup.id.x()
  %15 = mul i32 %14, %10
  %16 = add i32 %15, %5
  %17 = add nsw i32 %16, %2
  %18 = sext i32 %17 to i64
  %19 = getelementptr inbounds %struct.HIP_vector_type.0, %struct.HIP_vector_type.0 addrspace(1)* %0, i64 %18, i32 0, i32 0, i32 0, i64 0
  %20 = load float, float addrspace(1)* %19, align 16, !tbaa !16, !amdgpu.noclobber !6
  %21 = getelementptr inbounds %struct.HIP_vector_type.0, %struct.HIP_vector_type.0 addrspace(1)* %0, i64 %18, i32 0, i32 0, i32 0, i64 1
  %22 = load float, float addrspace(1)* %21, align 4, !tbaa !16, !amdgpu.noclobber !6
  %23 = getelementptr inbounds %struct.HIP_vector_type.0, %struct.HIP_vector_type.0 addrspace(1)* %0, i64 %18, i32 0, i32 0, i32 0, i64 2
  %24 = load float, float addrspace(1)* %23, align 8, !tbaa !16, !amdgpu.noclobber !6
  %25 = udiv i32 %13, %10
  %26 = mul i32 %25, %10
  %27 = icmp ugt i32 %13, %26
  %28 = zext i1 %27 to i32
  %29 = add i32 %25, %28
  %30 = mul i32 %29, %3
  %31 = icmp eq i32 %30, 0
  br i1 %31, label %43, label %32

32:                                               ; preds = %4
  %33 = getelementptr inbounds %struct.HIP_vector_type.0, %struct.HIP_vector_type.0 addrspace(1)* %0, i64 %18, i32 0, i32 0, i32 0, i64 3
  %34 = load float, float addrspace(1)* %33, align 4, !tbaa !16, !amdgpu.noclobber !6
  %35 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %5
  %36 = bitcast %struct.HIP_vector_type.0 addrspace(3)* %35 to i8 addrspace(3)*
  %37 = fpext float %34 to double
  %38 = fmul contract double %37, 6.674080e-11
  %39 = and i32 %10, 31
  %40 = icmp ult i16 %9, 32
  %41 = and i32 %10, 2016
  %42 = icmp eq i32 %39, 0
  br label %48

43:                                               ; preds = %134, %4
  %44 = phi float [ 0.000000e+00, %4 ], [ %135, %134 ]
  %45 = phi float [ 0.000000e+00, %4 ], [ %136, %134 ]
  %46 = phi float [ 0.000000e+00, %4 ], [ %137, %134 ]
  %47 = icmp slt i32 %16, 4096
  br i1 %47, label %2068, label %2073

48:                                               ; preds = %32, %134
  %49 = phi float [ 0.000000e+00, %32 ], [ %137, %134 ]
  %50 = phi float [ 0.000000e+00, %32 ], [ %136, %134 ]
  %51 = phi float [ 0.000000e+00, %32 ], [ %135, %134 ]
  %52 = phi i32 [ 0, %32 ], [ %138, %134 ]
  %53 = mul i32 %52, %10
  %54 = add i32 %53, %5
  %55 = zext i32 %54 to i64
  %56 = getelementptr inbounds %struct.HIP_vector_type.0, %struct.HIP_vector_type.0 addrspace(1)* %0, i64 %55
  %57 = bitcast %struct.HIP_vector_type.0 addrspace(1)* %56 to i8 addrspace(1)*
  tail call void @llvm.memcpy.p3i8.p1i8.i64(i8 addrspace(3)* noundef align 16 dereferenceable(16) %36, i8 addrspace(1)* noundef align 16 dereferenceable(16) %57, i64 16, i1 false)
  fence syncscope("workgroup") release
  tail call void @llvm.amdgcn.s.barrier()
  fence syncscope("workgroup") acquire
  br i1 %40, label %58, label %140

58:                                               ; preds = %2061, %48
  %59 = phi float [ undef, %48 ], [ %2062, %2061 ]
  %60 = phi float [ undef, %48 ], [ %2063, %2061 ]
  %61 = phi float [ undef, %48 ], [ %2064, %2061 ]
  %62 = phi float [ %49, %48 ], [ %2064, %2061 ]
  %63 = phi float [ %50, %48 ], [ %2063, %2061 ]
  %64 = phi float [ %51, %48 ], [ %2062, %2061 ]
  %65 = phi i32 [ 0, %48 ], [ %2065, %2061 ]
  br i1 %42, label %134, label %66

66:                                               ; preds = %58, %127
  %67 = phi float [ %130, %127 ], [ %62, %58 ]
  %68 = phi float [ %129, %127 ], [ %63, %58 ]
  %69 = phi float [ %128, %127 ], [ %64, %58 ]
  %70 = phi i32 [ %131, %127 ], [ %65, %58 ]
  %71 = phi i32 [ %132, %127 ], [ 0, %58 ]
  %72 = add i32 %70, %53
  %73 = icmp ne i32 %72, %17
  %74 = icmp slt i32 %72, 4096
  %75 = and i1 %73, %74
  br i1 %75, label %76, label %127

76:                                               ; preds = %66
  %77 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %70, i32 0, i32 0, i32 0
  %78 = load <4 x float>, <4 x float> addrspace(3)* %77, align 16
  %79 = extractelement <4 x float> %78, i64 0
  %80 = fsub contract float %79, %20
  %81 = extractelement <4 x float> %78, i64 1
  %82 = fsub contract float %81, %22
  %83 = extractelement <4 x float> %78, i64 2
  %84 = fsub contract float %83, %24
  %85 = fmul contract float %80, %80
  %86 = fmul contract float %82, %82
  %87 = fadd contract float %85, %86
  %88 = fmul contract float %84, %84
  %89 = fadd contract float %88, %87
  %90 = fcmp olt float %89, 0x39F0000000000000
  %91 = select i1 %90, float 0x41F0000000000000, float 1.000000e+00
  %92 = fmul float %89, %91
  %93 = tail call float @llvm.sqrt.f32(float %92)
  %94 = bitcast float %93 to i32
  %95 = add nsw i32 %94, -1
  %96 = bitcast i32 %95 to float
  %97 = add nsw i32 %94, 1
  %98 = bitcast i32 %97 to float
  %99 = tail call i1 @llvm.amdgcn.class.f32(float %92, i32 608)
  %100 = select i1 %90, float 0x3EF0000000000000, float 1.000000e+00
  %101 = fneg float %98
  %102 = tail call float @llvm.fma.f32(float %101, float %93, float %92)
  %103 = fcmp ogt float %102, 0.000000e+00
  %104 = fneg float %96
  %105 = tail call float @llvm.fma.f32(float %104, float %93, float %92)
  %106 = fcmp ole float %105, 0.000000e+00
  %107 = select i1 %106, float %96, float %93
  %108 = select i1 %103, float %98, float %107
  %109 = fmul float %100, %108
  %110 = select i1 %99, float %92, float %109
  %111 = fdiv contract float 1.000000e+00, %110
  %112 = extractelement <4 x float> %78, i64 3
  %113 = fpext float %112 to double
  %114 = fmul contract double %38, %113
  %115 = fpext float %89 to double
  %116 = fdiv contract double %114, %115
  %117 = fptrunc double %116 to float
  %118 = fmul contract float %80, %117
  %119 = fmul contract float %118, %111
  %120 = fmul contract float %82, %117
  %121 = fmul contract float %120, %111
  %122 = fmul contract float %84, %117
  %123 = fmul contract float %122, %111
  %124 = fadd contract float %69, %119
  %125 = fadd contract float %68, %121
  %126 = fadd contract float %67, %123
  br label %127

127:                                              ; preds = %76, %66
  %128 = phi float [ %124, %76 ], [ %69, %66 ]
  %129 = phi float [ %125, %76 ], [ %68, %66 ]
  %130 = phi float [ %126, %76 ], [ %67, %66 ]
  %131 = add nuw nsw i32 %70, 1
  %132 = add nuw nsw i32 %71, 1
  %133 = icmp eq i32 %132, %39
  br i1 %133, label %134, label %66, !llvm.loop !19

134:                                              ; preds = %127, %58
  %135 = phi float [ %59, %58 ], [ %128, %127 ]
  %136 = phi float [ %60, %58 ], [ %129, %127 ]
  %137 = phi float [ %61, %58 ], [ %130, %127 ]
  %138 = add nuw nsw i32 %52, 1
  %139 = icmp eq i32 %138, %30
  br i1 %139, label %43, label %48, !llvm.loop !21

140:                                              ; preds = %48, %2061
  %141 = phi float [ %2064, %2061 ], [ %49, %48 ]
  %142 = phi float [ %2063, %2061 ], [ %50, %48 ]
  %143 = phi float [ %2062, %2061 ], [ %51, %48 ]
  %144 = phi i32 [ %2065, %2061 ], [ 0, %48 ]
  %145 = phi i32 [ %2066, %2061 ], [ 0, %48 ]
  %146 = add i32 %144, %53
  %147 = icmp ne i32 %146, %17
  %148 = icmp slt i32 %146, 4096
  %149 = and i1 %147, %148
  br i1 %149, label %150, label %201

150:                                              ; preds = %140
  %151 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %144, i32 0, i32 0, i32 0
  %152 = load <4 x float>, <4 x float> addrspace(3)* %151, align 16
  %153 = extractelement <4 x float> %152, i64 0
  %154 = fsub contract float %153, %20
  %155 = extractelement <4 x float> %152, i64 1
  %156 = fsub contract float %155, %22
  %157 = extractelement <4 x float> %152, i64 2
  %158 = fsub contract float %157, %24
  %159 = fmul contract float %154, %154
  %160 = fmul contract float %156, %156
  %161 = fadd contract float %159, %160
  %162 = fmul contract float %158, %158
  %163 = fadd contract float %162, %161
  %164 = fcmp olt float %163, 0x39F0000000000000
  %165 = select i1 %164, float 0x41F0000000000000, float 1.000000e+00
  %166 = fmul float %163, %165
  %167 = tail call float @llvm.sqrt.f32(float %166)
  %168 = bitcast float %167 to i32
  %169 = add nsw i32 %168, -1
  %170 = bitcast i32 %169 to float
  %171 = add nsw i32 %168, 1
  %172 = bitcast i32 %171 to float
  %173 = tail call i1 @llvm.amdgcn.class.f32(float %166, i32 608)
  %174 = select i1 %164, float 0x3EF0000000000000, float 1.000000e+00
  %175 = fneg float %172
  %176 = tail call float @llvm.fma.f32(float %175, float %167, float %166)
  %177 = fcmp ogt float %176, 0.000000e+00
  %178 = fneg float %170
  %179 = tail call float @llvm.fma.f32(float %178, float %167, float %166)
  %180 = fcmp ole float %179, 0.000000e+00
  %181 = select i1 %180, float %170, float %167
  %182 = select i1 %177, float %172, float %181
  %183 = fmul float %174, %182
  %184 = select i1 %173, float %166, float %183
  %185 = fdiv contract float 1.000000e+00, %184
  %186 = extractelement <4 x float> %152, i64 3
  %187 = fpext float %186 to double
  %188 = fmul contract double %38, %187
  %189 = fpext float %163 to double
  %190 = fdiv contract double %188, %189
  %191 = fptrunc double %190 to float
  %192 = fmul contract float %154, %191
  %193 = fmul contract float %192, %185
  %194 = fmul contract float %156, %191
  %195 = fmul contract float %194, %185
  %196 = fmul contract float %158, %191
  %197 = fmul contract float %196, %185
  %198 = fadd contract float %143, %193
  %199 = fadd contract float %142, %195
  %200 = fadd contract float %141, %197
  br label %201

201:                                              ; preds = %140, %150
  %202 = phi float [ %198, %150 ], [ %143, %140 ]
  %203 = phi float [ %199, %150 ], [ %142, %140 ]
  %204 = phi float [ %200, %150 ], [ %141, %140 ]
  %205 = or i32 %144, 1
  %206 = add i32 %205, %53
  %207 = icmp ne i32 %206, %17
  %208 = icmp slt i32 %206, 4096
  %209 = and i1 %207, %208
  br i1 %209, label %210, label %261

210:                                              ; preds = %201
  %211 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %205, i32 0, i32 0, i32 0
  %212 = load <4 x float>, <4 x float> addrspace(3)* %211, align 16
  %213 = extractelement <4 x float> %212, i64 0
  %214 = fsub contract float %213, %20
  %215 = extractelement <4 x float> %212, i64 1
  %216 = fsub contract float %215, %22
  %217 = extractelement <4 x float> %212, i64 2
  %218 = fsub contract float %217, %24
  %219 = fmul contract float %214, %214
  %220 = fmul contract float %216, %216
  %221 = fadd contract float %219, %220
  %222 = fmul contract float %218, %218
  %223 = fadd contract float %222, %221
  %224 = fcmp olt float %223, 0x39F0000000000000
  %225 = select i1 %224, float 0x41F0000000000000, float 1.000000e+00
  %226 = fmul float %223, %225
  %227 = tail call float @llvm.sqrt.f32(float %226)
  %228 = bitcast float %227 to i32
  %229 = add nsw i32 %228, -1
  %230 = bitcast i32 %229 to float
  %231 = add nsw i32 %228, 1
  %232 = bitcast i32 %231 to float
  %233 = tail call i1 @llvm.amdgcn.class.f32(float %226, i32 608)
  %234 = select i1 %224, float 0x3EF0000000000000, float 1.000000e+00
  %235 = fneg float %232
  %236 = tail call float @llvm.fma.f32(float %235, float %227, float %226)
  %237 = fcmp ogt float %236, 0.000000e+00
  %238 = fneg float %230
  %239 = tail call float @llvm.fma.f32(float %238, float %227, float %226)
  %240 = fcmp ole float %239, 0.000000e+00
  %241 = select i1 %240, float %230, float %227
  %242 = select i1 %237, float %232, float %241
  %243 = fmul float %234, %242
  %244 = select i1 %233, float %226, float %243
  %245 = fdiv contract float 1.000000e+00, %244
  %246 = extractelement <4 x float> %212, i64 3
  %247 = fpext float %246 to double
  %248 = fmul contract double %38, %247
  %249 = fpext float %223 to double
  %250 = fdiv contract double %248, %249
  %251 = fptrunc double %250 to float
  %252 = fmul contract float %214, %251
  %253 = fmul contract float %252, %245
  %254 = fmul contract float %216, %251
  %255 = fmul contract float %254, %245
  %256 = fmul contract float %218, %251
  %257 = fmul contract float %256, %245
  %258 = fadd contract float %202, %253
  %259 = fadd contract float %203, %255
  %260 = fadd contract float %204, %257
  br label %261

261:                                              ; preds = %210, %201
  %262 = phi float [ %258, %210 ], [ %202, %201 ]
  %263 = phi float [ %259, %210 ], [ %203, %201 ]
  %264 = phi float [ %260, %210 ], [ %204, %201 ]
  %265 = or i32 %144, 2
  %266 = add i32 %265, %53
  %267 = icmp ne i32 %266, %17
  %268 = icmp slt i32 %266, 4096
  %269 = and i1 %267, %268
  br i1 %269, label %270, label %321

270:                                              ; preds = %261
  %271 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %265, i32 0, i32 0, i32 0
  %272 = load <4 x float>, <4 x float> addrspace(3)* %271, align 16
  %273 = extractelement <4 x float> %272, i64 0
  %274 = fsub contract float %273, %20
  %275 = extractelement <4 x float> %272, i64 1
  %276 = fsub contract float %275, %22
  %277 = extractelement <4 x float> %272, i64 2
  %278 = fsub contract float %277, %24
  %279 = fmul contract float %274, %274
  %280 = fmul contract float %276, %276
  %281 = fadd contract float %279, %280
  %282 = fmul contract float %278, %278
  %283 = fadd contract float %282, %281
  %284 = fcmp olt float %283, 0x39F0000000000000
  %285 = select i1 %284, float 0x41F0000000000000, float 1.000000e+00
  %286 = fmul float %283, %285
  %287 = tail call float @llvm.sqrt.f32(float %286)
  %288 = bitcast float %287 to i32
  %289 = add nsw i32 %288, -1
  %290 = bitcast i32 %289 to float
  %291 = add nsw i32 %288, 1
  %292 = bitcast i32 %291 to float
  %293 = tail call i1 @llvm.amdgcn.class.f32(float %286, i32 608)
  %294 = select i1 %284, float 0x3EF0000000000000, float 1.000000e+00
  %295 = fneg float %292
  %296 = tail call float @llvm.fma.f32(float %295, float %287, float %286)
  %297 = fcmp ogt float %296, 0.000000e+00
  %298 = fneg float %290
  %299 = tail call float @llvm.fma.f32(float %298, float %287, float %286)
  %300 = fcmp ole float %299, 0.000000e+00
  %301 = select i1 %300, float %290, float %287
  %302 = select i1 %297, float %292, float %301
  %303 = fmul float %294, %302
  %304 = select i1 %293, float %286, float %303
  %305 = fdiv contract float 1.000000e+00, %304
  %306 = extractelement <4 x float> %272, i64 3
  %307 = fpext float %306 to double
  %308 = fmul contract double %38, %307
  %309 = fpext float %283 to double
  %310 = fdiv contract double %308, %309
  %311 = fptrunc double %310 to float
  %312 = fmul contract float %274, %311
  %313 = fmul contract float %312, %305
  %314 = fmul contract float %276, %311
  %315 = fmul contract float %314, %305
  %316 = fmul contract float %278, %311
  %317 = fmul contract float %316, %305
  %318 = fadd contract float %262, %313
  %319 = fadd contract float %263, %315
  %320 = fadd contract float %264, %317
  br label %321

321:                                              ; preds = %270, %261
  %322 = phi float [ %318, %270 ], [ %262, %261 ]
  %323 = phi float [ %319, %270 ], [ %263, %261 ]
  %324 = phi float [ %320, %270 ], [ %264, %261 ]
  %325 = or i32 %144, 3
  %326 = add i32 %325, %53
  %327 = icmp ne i32 %326, %17
  %328 = icmp slt i32 %326, 4096
  %329 = and i1 %327, %328
  br i1 %329, label %330, label %381

330:                                              ; preds = %321
  %331 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %325, i32 0, i32 0, i32 0
  %332 = load <4 x float>, <4 x float> addrspace(3)* %331, align 16
  %333 = extractelement <4 x float> %332, i64 0
  %334 = fsub contract float %333, %20
  %335 = extractelement <4 x float> %332, i64 1
  %336 = fsub contract float %335, %22
  %337 = extractelement <4 x float> %332, i64 2
  %338 = fsub contract float %337, %24
  %339 = fmul contract float %334, %334
  %340 = fmul contract float %336, %336
  %341 = fadd contract float %339, %340
  %342 = fmul contract float %338, %338
  %343 = fadd contract float %342, %341
  %344 = fcmp olt float %343, 0x39F0000000000000
  %345 = select i1 %344, float 0x41F0000000000000, float 1.000000e+00
  %346 = fmul float %343, %345
  %347 = tail call float @llvm.sqrt.f32(float %346)
  %348 = bitcast float %347 to i32
  %349 = add nsw i32 %348, -1
  %350 = bitcast i32 %349 to float
  %351 = add nsw i32 %348, 1
  %352 = bitcast i32 %351 to float
  %353 = tail call i1 @llvm.amdgcn.class.f32(float %346, i32 608)
  %354 = select i1 %344, float 0x3EF0000000000000, float 1.000000e+00
  %355 = fneg float %352
  %356 = tail call float @llvm.fma.f32(float %355, float %347, float %346)
  %357 = fcmp ogt float %356, 0.000000e+00
  %358 = fneg float %350
  %359 = tail call float @llvm.fma.f32(float %358, float %347, float %346)
  %360 = fcmp ole float %359, 0.000000e+00
  %361 = select i1 %360, float %350, float %347
  %362 = select i1 %357, float %352, float %361
  %363 = fmul float %354, %362
  %364 = select i1 %353, float %346, float %363
  %365 = fdiv contract float 1.000000e+00, %364
  %366 = extractelement <4 x float> %332, i64 3
  %367 = fpext float %366 to double
  %368 = fmul contract double %38, %367
  %369 = fpext float %343 to double
  %370 = fdiv contract double %368, %369
  %371 = fptrunc double %370 to float
  %372 = fmul contract float %334, %371
  %373 = fmul contract float %372, %365
  %374 = fmul contract float %336, %371
  %375 = fmul contract float %374, %365
  %376 = fmul contract float %338, %371
  %377 = fmul contract float %376, %365
  %378 = fadd contract float %322, %373
  %379 = fadd contract float %323, %375
  %380 = fadd contract float %324, %377
  br label %381

381:                                              ; preds = %330, %321
  %382 = phi float [ %378, %330 ], [ %322, %321 ]
  %383 = phi float [ %379, %330 ], [ %323, %321 ]
  %384 = phi float [ %380, %330 ], [ %324, %321 ]
  %385 = or i32 %144, 4
  %386 = add i32 %385, %53
  %387 = icmp ne i32 %386, %17
  %388 = icmp slt i32 %386, 4096
  %389 = and i1 %387, %388
  br i1 %389, label %390, label %441

390:                                              ; preds = %381
  %391 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %385, i32 0, i32 0, i32 0
  %392 = load <4 x float>, <4 x float> addrspace(3)* %391, align 16
  %393 = extractelement <4 x float> %392, i64 0
  %394 = fsub contract float %393, %20
  %395 = extractelement <4 x float> %392, i64 1
  %396 = fsub contract float %395, %22
  %397 = extractelement <4 x float> %392, i64 2
  %398 = fsub contract float %397, %24
  %399 = fmul contract float %394, %394
  %400 = fmul contract float %396, %396
  %401 = fadd contract float %399, %400
  %402 = fmul contract float %398, %398
  %403 = fadd contract float %402, %401
  %404 = fcmp olt float %403, 0x39F0000000000000
  %405 = select i1 %404, float 0x41F0000000000000, float 1.000000e+00
  %406 = fmul float %403, %405
  %407 = tail call float @llvm.sqrt.f32(float %406)
  %408 = bitcast float %407 to i32
  %409 = add nsw i32 %408, -1
  %410 = bitcast i32 %409 to float
  %411 = add nsw i32 %408, 1
  %412 = bitcast i32 %411 to float
  %413 = tail call i1 @llvm.amdgcn.class.f32(float %406, i32 608)
  %414 = select i1 %404, float 0x3EF0000000000000, float 1.000000e+00
  %415 = fneg float %412
  %416 = tail call float @llvm.fma.f32(float %415, float %407, float %406)
  %417 = fcmp ogt float %416, 0.000000e+00
  %418 = fneg float %410
  %419 = tail call float @llvm.fma.f32(float %418, float %407, float %406)
  %420 = fcmp ole float %419, 0.000000e+00
  %421 = select i1 %420, float %410, float %407
  %422 = select i1 %417, float %412, float %421
  %423 = fmul float %414, %422
  %424 = select i1 %413, float %406, float %423
  %425 = fdiv contract float 1.000000e+00, %424
  %426 = extractelement <4 x float> %392, i64 3
  %427 = fpext float %426 to double
  %428 = fmul contract double %38, %427
  %429 = fpext float %403 to double
  %430 = fdiv contract double %428, %429
  %431 = fptrunc double %430 to float
  %432 = fmul contract float %394, %431
  %433 = fmul contract float %432, %425
  %434 = fmul contract float %396, %431
  %435 = fmul contract float %434, %425
  %436 = fmul contract float %398, %431
  %437 = fmul contract float %436, %425
  %438 = fadd contract float %382, %433
  %439 = fadd contract float %383, %435
  %440 = fadd contract float %384, %437
  br label %441

441:                                              ; preds = %390, %381
  %442 = phi float [ %438, %390 ], [ %382, %381 ]
  %443 = phi float [ %439, %390 ], [ %383, %381 ]
  %444 = phi float [ %440, %390 ], [ %384, %381 ]
  %445 = or i32 %144, 5
  %446 = add i32 %445, %53
  %447 = icmp ne i32 %446, %17
  %448 = icmp slt i32 %446, 4096
  %449 = and i1 %447, %448
  br i1 %449, label %450, label %501

450:                                              ; preds = %441
  %451 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %445, i32 0, i32 0, i32 0
  %452 = load <4 x float>, <4 x float> addrspace(3)* %451, align 16
  %453 = extractelement <4 x float> %452, i64 0
  %454 = fsub contract float %453, %20
  %455 = extractelement <4 x float> %452, i64 1
  %456 = fsub contract float %455, %22
  %457 = extractelement <4 x float> %452, i64 2
  %458 = fsub contract float %457, %24
  %459 = fmul contract float %454, %454
  %460 = fmul contract float %456, %456
  %461 = fadd contract float %459, %460
  %462 = fmul contract float %458, %458
  %463 = fadd contract float %462, %461
  %464 = fcmp olt float %463, 0x39F0000000000000
  %465 = select i1 %464, float 0x41F0000000000000, float 1.000000e+00
  %466 = fmul float %463, %465
  %467 = tail call float @llvm.sqrt.f32(float %466)
  %468 = bitcast float %467 to i32
  %469 = add nsw i32 %468, -1
  %470 = bitcast i32 %469 to float
  %471 = add nsw i32 %468, 1
  %472 = bitcast i32 %471 to float
  %473 = tail call i1 @llvm.amdgcn.class.f32(float %466, i32 608)
  %474 = select i1 %464, float 0x3EF0000000000000, float 1.000000e+00
  %475 = fneg float %472
  %476 = tail call float @llvm.fma.f32(float %475, float %467, float %466)
  %477 = fcmp ogt float %476, 0.000000e+00
  %478 = fneg float %470
  %479 = tail call float @llvm.fma.f32(float %478, float %467, float %466)
  %480 = fcmp ole float %479, 0.000000e+00
  %481 = select i1 %480, float %470, float %467
  %482 = select i1 %477, float %472, float %481
  %483 = fmul float %474, %482
  %484 = select i1 %473, float %466, float %483
  %485 = fdiv contract float 1.000000e+00, %484
  %486 = extractelement <4 x float> %452, i64 3
  %487 = fpext float %486 to double
  %488 = fmul contract double %38, %487
  %489 = fpext float %463 to double
  %490 = fdiv contract double %488, %489
  %491 = fptrunc double %490 to float
  %492 = fmul contract float %454, %491
  %493 = fmul contract float %492, %485
  %494 = fmul contract float %456, %491
  %495 = fmul contract float %494, %485
  %496 = fmul contract float %458, %491
  %497 = fmul contract float %496, %485
  %498 = fadd contract float %442, %493
  %499 = fadd contract float %443, %495
  %500 = fadd contract float %444, %497
  br label %501

501:                                              ; preds = %450, %441
  %502 = phi float [ %498, %450 ], [ %442, %441 ]
  %503 = phi float [ %499, %450 ], [ %443, %441 ]
  %504 = phi float [ %500, %450 ], [ %444, %441 ]
  %505 = or i32 %144, 6
  %506 = add i32 %505, %53
  %507 = icmp ne i32 %506, %17
  %508 = icmp slt i32 %506, 4096
  %509 = and i1 %507, %508
  br i1 %509, label %510, label %561

510:                                              ; preds = %501
  %511 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %505, i32 0, i32 0, i32 0
  %512 = load <4 x float>, <4 x float> addrspace(3)* %511, align 16
  %513 = extractelement <4 x float> %512, i64 0
  %514 = fsub contract float %513, %20
  %515 = extractelement <4 x float> %512, i64 1
  %516 = fsub contract float %515, %22
  %517 = extractelement <4 x float> %512, i64 2
  %518 = fsub contract float %517, %24
  %519 = fmul contract float %514, %514
  %520 = fmul contract float %516, %516
  %521 = fadd contract float %519, %520
  %522 = fmul contract float %518, %518
  %523 = fadd contract float %522, %521
  %524 = fcmp olt float %523, 0x39F0000000000000
  %525 = select i1 %524, float 0x41F0000000000000, float 1.000000e+00
  %526 = fmul float %523, %525
  %527 = tail call float @llvm.sqrt.f32(float %526)
  %528 = bitcast float %527 to i32
  %529 = add nsw i32 %528, -1
  %530 = bitcast i32 %529 to float
  %531 = add nsw i32 %528, 1
  %532 = bitcast i32 %531 to float
  %533 = tail call i1 @llvm.amdgcn.class.f32(float %526, i32 608)
  %534 = select i1 %524, float 0x3EF0000000000000, float 1.000000e+00
  %535 = fneg float %532
  %536 = tail call float @llvm.fma.f32(float %535, float %527, float %526)
  %537 = fcmp ogt float %536, 0.000000e+00
  %538 = fneg float %530
  %539 = tail call float @llvm.fma.f32(float %538, float %527, float %526)
  %540 = fcmp ole float %539, 0.000000e+00
  %541 = select i1 %540, float %530, float %527
  %542 = select i1 %537, float %532, float %541
  %543 = fmul float %534, %542
  %544 = select i1 %533, float %526, float %543
  %545 = fdiv contract float 1.000000e+00, %544
  %546 = extractelement <4 x float> %512, i64 3
  %547 = fpext float %546 to double
  %548 = fmul contract double %38, %547
  %549 = fpext float %523 to double
  %550 = fdiv contract double %548, %549
  %551 = fptrunc double %550 to float
  %552 = fmul contract float %514, %551
  %553 = fmul contract float %552, %545
  %554 = fmul contract float %516, %551
  %555 = fmul contract float %554, %545
  %556 = fmul contract float %518, %551
  %557 = fmul contract float %556, %545
  %558 = fadd contract float %502, %553
  %559 = fadd contract float %503, %555
  %560 = fadd contract float %504, %557
  br label %561

561:                                              ; preds = %510, %501
  %562 = phi float [ %558, %510 ], [ %502, %501 ]
  %563 = phi float [ %559, %510 ], [ %503, %501 ]
  %564 = phi float [ %560, %510 ], [ %504, %501 ]
  %565 = or i32 %144, 7
  %566 = add i32 %565, %53
  %567 = icmp ne i32 %566, %17
  %568 = icmp slt i32 %566, 4096
  %569 = and i1 %567, %568
  br i1 %569, label %570, label %621

570:                                              ; preds = %561
  %571 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %565, i32 0, i32 0, i32 0
  %572 = load <4 x float>, <4 x float> addrspace(3)* %571, align 16
  %573 = extractelement <4 x float> %572, i64 0
  %574 = fsub contract float %573, %20
  %575 = extractelement <4 x float> %572, i64 1
  %576 = fsub contract float %575, %22
  %577 = extractelement <4 x float> %572, i64 2
  %578 = fsub contract float %577, %24
  %579 = fmul contract float %574, %574
  %580 = fmul contract float %576, %576
  %581 = fadd contract float %579, %580
  %582 = fmul contract float %578, %578
  %583 = fadd contract float %582, %581
  %584 = fcmp olt float %583, 0x39F0000000000000
  %585 = select i1 %584, float 0x41F0000000000000, float 1.000000e+00
  %586 = fmul float %583, %585
  %587 = tail call float @llvm.sqrt.f32(float %586)
  %588 = bitcast float %587 to i32
  %589 = add nsw i32 %588, -1
  %590 = bitcast i32 %589 to float
  %591 = add nsw i32 %588, 1
  %592 = bitcast i32 %591 to float
  %593 = tail call i1 @llvm.amdgcn.class.f32(float %586, i32 608)
  %594 = select i1 %584, float 0x3EF0000000000000, float 1.000000e+00
  %595 = fneg float %592
  %596 = tail call float @llvm.fma.f32(float %595, float %587, float %586)
  %597 = fcmp ogt float %596, 0.000000e+00
  %598 = fneg float %590
  %599 = tail call float @llvm.fma.f32(float %598, float %587, float %586)
  %600 = fcmp ole float %599, 0.000000e+00
  %601 = select i1 %600, float %590, float %587
  %602 = select i1 %597, float %592, float %601
  %603 = fmul float %594, %602
  %604 = select i1 %593, float %586, float %603
  %605 = fdiv contract float 1.000000e+00, %604
  %606 = extractelement <4 x float> %572, i64 3
  %607 = fpext float %606 to double
  %608 = fmul contract double %38, %607
  %609 = fpext float %583 to double
  %610 = fdiv contract double %608, %609
  %611 = fptrunc double %610 to float
  %612 = fmul contract float %574, %611
  %613 = fmul contract float %612, %605
  %614 = fmul contract float %576, %611
  %615 = fmul contract float %614, %605
  %616 = fmul contract float %578, %611
  %617 = fmul contract float %616, %605
  %618 = fadd contract float %562, %613
  %619 = fadd contract float %563, %615
  %620 = fadd contract float %564, %617
  br label %621

621:                                              ; preds = %570, %561
  %622 = phi float [ %618, %570 ], [ %562, %561 ]
  %623 = phi float [ %619, %570 ], [ %563, %561 ]
  %624 = phi float [ %620, %570 ], [ %564, %561 ]
  %625 = or i32 %144, 8
  %626 = add i32 %625, %53
  %627 = icmp ne i32 %626, %17
  %628 = icmp slt i32 %626, 4096
  %629 = and i1 %627, %628
  br i1 %629, label %630, label %681

630:                                              ; preds = %621
  %631 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %625, i32 0, i32 0, i32 0
  %632 = load <4 x float>, <4 x float> addrspace(3)* %631, align 16
  %633 = extractelement <4 x float> %632, i64 0
  %634 = fsub contract float %633, %20
  %635 = extractelement <4 x float> %632, i64 1
  %636 = fsub contract float %635, %22
  %637 = extractelement <4 x float> %632, i64 2
  %638 = fsub contract float %637, %24
  %639 = fmul contract float %634, %634
  %640 = fmul contract float %636, %636
  %641 = fadd contract float %639, %640
  %642 = fmul contract float %638, %638
  %643 = fadd contract float %642, %641
  %644 = fcmp olt float %643, 0x39F0000000000000
  %645 = select i1 %644, float 0x41F0000000000000, float 1.000000e+00
  %646 = fmul float %643, %645
  %647 = tail call float @llvm.sqrt.f32(float %646)
  %648 = bitcast float %647 to i32
  %649 = add nsw i32 %648, -1
  %650 = bitcast i32 %649 to float
  %651 = add nsw i32 %648, 1
  %652 = bitcast i32 %651 to float
  %653 = tail call i1 @llvm.amdgcn.class.f32(float %646, i32 608)
  %654 = select i1 %644, float 0x3EF0000000000000, float 1.000000e+00
  %655 = fneg float %652
  %656 = tail call float @llvm.fma.f32(float %655, float %647, float %646)
  %657 = fcmp ogt float %656, 0.000000e+00
  %658 = fneg float %650
  %659 = tail call float @llvm.fma.f32(float %658, float %647, float %646)
  %660 = fcmp ole float %659, 0.000000e+00
  %661 = select i1 %660, float %650, float %647
  %662 = select i1 %657, float %652, float %661
  %663 = fmul float %654, %662
  %664 = select i1 %653, float %646, float %663
  %665 = fdiv contract float 1.000000e+00, %664
  %666 = extractelement <4 x float> %632, i64 3
  %667 = fpext float %666 to double
  %668 = fmul contract double %38, %667
  %669 = fpext float %643 to double
  %670 = fdiv contract double %668, %669
  %671 = fptrunc double %670 to float
  %672 = fmul contract float %634, %671
  %673 = fmul contract float %672, %665
  %674 = fmul contract float %636, %671
  %675 = fmul contract float %674, %665
  %676 = fmul contract float %638, %671
  %677 = fmul contract float %676, %665
  %678 = fadd contract float %622, %673
  %679 = fadd contract float %623, %675
  %680 = fadd contract float %624, %677
  br label %681

681:                                              ; preds = %630, %621
  %682 = phi float [ %678, %630 ], [ %622, %621 ]
  %683 = phi float [ %679, %630 ], [ %623, %621 ]
  %684 = phi float [ %680, %630 ], [ %624, %621 ]
  %685 = or i32 %144, 9
  %686 = add i32 %685, %53
  %687 = icmp ne i32 %686, %17
  %688 = icmp slt i32 %686, 4096
  %689 = and i1 %687, %688
  br i1 %689, label %690, label %741

690:                                              ; preds = %681
  %691 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %685, i32 0, i32 0, i32 0
  %692 = load <4 x float>, <4 x float> addrspace(3)* %691, align 16
  %693 = extractelement <4 x float> %692, i64 0
  %694 = fsub contract float %693, %20
  %695 = extractelement <4 x float> %692, i64 1
  %696 = fsub contract float %695, %22
  %697 = extractelement <4 x float> %692, i64 2
  %698 = fsub contract float %697, %24
  %699 = fmul contract float %694, %694
  %700 = fmul contract float %696, %696
  %701 = fadd contract float %699, %700
  %702 = fmul contract float %698, %698
  %703 = fadd contract float %702, %701
  %704 = fcmp olt float %703, 0x39F0000000000000
  %705 = select i1 %704, float 0x41F0000000000000, float 1.000000e+00
  %706 = fmul float %703, %705
  %707 = tail call float @llvm.sqrt.f32(float %706)
  %708 = bitcast float %707 to i32
  %709 = add nsw i32 %708, -1
  %710 = bitcast i32 %709 to float
  %711 = add nsw i32 %708, 1
  %712 = bitcast i32 %711 to float
  %713 = tail call i1 @llvm.amdgcn.class.f32(float %706, i32 608)
  %714 = select i1 %704, float 0x3EF0000000000000, float 1.000000e+00
  %715 = fneg float %712
  %716 = tail call float @llvm.fma.f32(float %715, float %707, float %706)
  %717 = fcmp ogt float %716, 0.000000e+00
  %718 = fneg float %710
  %719 = tail call float @llvm.fma.f32(float %718, float %707, float %706)
  %720 = fcmp ole float %719, 0.000000e+00
  %721 = select i1 %720, float %710, float %707
  %722 = select i1 %717, float %712, float %721
  %723 = fmul float %714, %722
  %724 = select i1 %713, float %706, float %723
  %725 = fdiv contract float 1.000000e+00, %724
  %726 = extractelement <4 x float> %692, i64 3
  %727 = fpext float %726 to double
  %728 = fmul contract double %38, %727
  %729 = fpext float %703 to double
  %730 = fdiv contract double %728, %729
  %731 = fptrunc double %730 to float
  %732 = fmul contract float %694, %731
  %733 = fmul contract float %732, %725
  %734 = fmul contract float %696, %731
  %735 = fmul contract float %734, %725
  %736 = fmul contract float %698, %731
  %737 = fmul contract float %736, %725
  %738 = fadd contract float %682, %733
  %739 = fadd contract float %683, %735
  %740 = fadd contract float %684, %737
  br label %741

741:                                              ; preds = %690, %681
  %742 = phi float [ %738, %690 ], [ %682, %681 ]
  %743 = phi float [ %739, %690 ], [ %683, %681 ]
  %744 = phi float [ %740, %690 ], [ %684, %681 ]
  %745 = or i32 %144, 10
  %746 = add i32 %745, %53
  %747 = icmp ne i32 %746, %17
  %748 = icmp slt i32 %746, 4096
  %749 = and i1 %747, %748
  br i1 %749, label %750, label %801

750:                                              ; preds = %741
  %751 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %745, i32 0, i32 0, i32 0
  %752 = load <4 x float>, <4 x float> addrspace(3)* %751, align 16
  %753 = extractelement <4 x float> %752, i64 0
  %754 = fsub contract float %753, %20
  %755 = extractelement <4 x float> %752, i64 1
  %756 = fsub contract float %755, %22
  %757 = extractelement <4 x float> %752, i64 2
  %758 = fsub contract float %757, %24
  %759 = fmul contract float %754, %754
  %760 = fmul contract float %756, %756
  %761 = fadd contract float %759, %760
  %762 = fmul contract float %758, %758
  %763 = fadd contract float %762, %761
  %764 = fcmp olt float %763, 0x39F0000000000000
  %765 = select i1 %764, float 0x41F0000000000000, float 1.000000e+00
  %766 = fmul float %763, %765
  %767 = tail call float @llvm.sqrt.f32(float %766)
  %768 = bitcast float %767 to i32
  %769 = add nsw i32 %768, -1
  %770 = bitcast i32 %769 to float
  %771 = add nsw i32 %768, 1
  %772 = bitcast i32 %771 to float
  %773 = tail call i1 @llvm.amdgcn.class.f32(float %766, i32 608)
  %774 = select i1 %764, float 0x3EF0000000000000, float 1.000000e+00
  %775 = fneg float %772
  %776 = tail call float @llvm.fma.f32(float %775, float %767, float %766)
  %777 = fcmp ogt float %776, 0.000000e+00
  %778 = fneg float %770
  %779 = tail call float @llvm.fma.f32(float %778, float %767, float %766)
  %780 = fcmp ole float %779, 0.000000e+00
  %781 = select i1 %780, float %770, float %767
  %782 = select i1 %777, float %772, float %781
  %783 = fmul float %774, %782
  %784 = select i1 %773, float %766, float %783
  %785 = fdiv contract float 1.000000e+00, %784
  %786 = extractelement <4 x float> %752, i64 3
  %787 = fpext float %786 to double
  %788 = fmul contract double %38, %787
  %789 = fpext float %763 to double
  %790 = fdiv contract double %788, %789
  %791 = fptrunc double %790 to float
  %792 = fmul contract float %754, %791
  %793 = fmul contract float %792, %785
  %794 = fmul contract float %756, %791
  %795 = fmul contract float %794, %785
  %796 = fmul contract float %758, %791
  %797 = fmul contract float %796, %785
  %798 = fadd contract float %742, %793
  %799 = fadd contract float %743, %795
  %800 = fadd contract float %744, %797
  br label %801

801:                                              ; preds = %750, %741
  %802 = phi float [ %798, %750 ], [ %742, %741 ]
  %803 = phi float [ %799, %750 ], [ %743, %741 ]
  %804 = phi float [ %800, %750 ], [ %744, %741 ]
  %805 = or i32 %144, 11
  %806 = add i32 %805, %53
  %807 = icmp ne i32 %806, %17
  %808 = icmp slt i32 %806, 4096
  %809 = and i1 %807, %808
  br i1 %809, label %810, label %861

810:                                              ; preds = %801
  %811 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %805, i32 0, i32 0, i32 0
  %812 = load <4 x float>, <4 x float> addrspace(3)* %811, align 16
  %813 = extractelement <4 x float> %812, i64 0
  %814 = fsub contract float %813, %20
  %815 = extractelement <4 x float> %812, i64 1
  %816 = fsub contract float %815, %22
  %817 = extractelement <4 x float> %812, i64 2
  %818 = fsub contract float %817, %24
  %819 = fmul contract float %814, %814
  %820 = fmul contract float %816, %816
  %821 = fadd contract float %819, %820
  %822 = fmul contract float %818, %818
  %823 = fadd contract float %822, %821
  %824 = fcmp olt float %823, 0x39F0000000000000
  %825 = select i1 %824, float 0x41F0000000000000, float 1.000000e+00
  %826 = fmul float %823, %825
  %827 = tail call float @llvm.sqrt.f32(float %826)
  %828 = bitcast float %827 to i32
  %829 = add nsw i32 %828, -1
  %830 = bitcast i32 %829 to float
  %831 = add nsw i32 %828, 1
  %832 = bitcast i32 %831 to float
  %833 = tail call i1 @llvm.amdgcn.class.f32(float %826, i32 608)
  %834 = select i1 %824, float 0x3EF0000000000000, float 1.000000e+00
  %835 = fneg float %832
  %836 = tail call float @llvm.fma.f32(float %835, float %827, float %826)
  %837 = fcmp ogt float %836, 0.000000e+00
  %838 = fneg float %830
  %839 = tail call float @llvm.fma.f32(float %838, float %827, float %826)
  %840 = fcmp ole float %839, 0.000000e+00
  %841 = select i1 %840, float %830, float %827
  %842 = select i1 %837, float %832, float %841
  %843 = fmul float %834, %842
  %844 = select i1 %833, float %826, float %843
  %845 = fdiv contract float 1.000000e+00, %844
  %846 = extractelement <4 x float> %812, i64 3
  %847 = fpext float %846 to double
  %848 = fmul contract double %38, %847
  %849 = fpext float %823 to double
  %850 = fdiv contract double %848, %849
  %851 = fptrunc double %850 to float
  %852 = fmul contract float %814, %851
  %853 = fmul contract float %852, %845
  %854 = fmul contract float %816, %851
  %855 = fmul contract float %854, %845
  %856 = fmul contract float %818, %851
  %857 = fmul contract float %856, %845
  %858 = fadd contract float %802, %853
  %859 = fadd contract float %803, %855
  %860 = fadd contract float %804, %857
  br label %861

861:                                              ; preds = %810, %801
  %862 = phi float [ %858, %810 ], [ %802, %801 ]
  %863 = phi float [ %859, %810 ], [ %803, %801 ]
  %864 = phi float [ %860, %810 ], [ %804, %801 ]
  %865 = or i32 %144, 12
  %866 = add i32 %865, %53
  %867 = icmp ne i32 %866, %17
  %868 = icmp slt i32 %866, 4096
  %869 = and i1 %867, %868
  br i1 %869, label %870, label %921

870:                                              ; preds = %861
  %871 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %865, i32 0, i32 0, i32 0
  %872 = load <4 x float>, <4 x float> addrspace(3)* %871, align 16
  %873 = extractelement <4 x float> %872, i64 0
  %874 = fsub contract float %873, %20
  %875 = extractelement <4 x float> %872, i64 1
  %876 = fsub contract float %875, %22
  %877 = extractelement <4 x float> %872, i64 2
  %878 = fsub contract float %877, %24
  %879 = fmul contract float %874, %874
  %880 = fmul contract float %876, %876
  %881 = fadd contract float %879, %880
  %882 = fmul contract float %878, %878
  %883 = fadd contract float %882, %881
  %884 = fcmp olt float %883, 0x39F0000000000000
  %885 = select i1 %884, float 0x41F0000000000000, float 1.000000e+00
  %886 = fmul float %883, %885
  %887 = tail call float @llvm.sqrt.f32(float %886)
  %888 = bitcast float %887 to i32
  %889 = add nsw i32 %888, -1
  %890 = bitcast i32 %889 to float
  %891 = add nsw i32 %888, 1
  %892 = bitcast i32 %891 to float
  %893 = tail call i1 @llvm.amdgcn.class.f32(float %886, i32 608)
  %894 = select i1 %884, float 0x3EF0000000000000, float 1.000000e+00
  %895 = fneg float %892
  %896 = tail call float @llvm.fma.f32(float %895, float %887, float %886)
  %897 = fcmp ogt float %896, 0.000000e+00
  %898 = fneg float %890
  %899 = tail call float @llvm.fma.f32(float %898, float %887, float %886)
  %900 = fcmp ole float %899, 0.000000e+00
  %901 = select i1 %900, float %890, float %887
  %902 = select i1 %897, float %892, float %901
  %903 = fmul float %894, %902
  %904 = select i1 %893, float %886, float %903
  %905 = fdiv contract float 1.000000e+00, %904
  %906 = extractelement <4 x float> %872, i64 3
  %907 = fpext float %906 to double
  %908 = fmul contract double %38, %907
  %909 = fpext float %883 to double
  %910 = fdiv contract double %908, %909
  %911 = fptrunc double %910 to float
  %912 = fmul contract float %874, %911
  %913 = fmul contract float %912, %905
  %914 = fmul contract float %876, %911
  %915 = fmul contract float %914, %905
  %916 = fmul contract float %878, %911
  %917 = fmul contract float %916, %905
  %918 = fadd contract float %862, %913
  %919 = fadd contract float %863, %915
  %920 = fadd contract float %864, %917
  br label %921

921:                                              ; preds = %870, %861
  %922 = phi float [ %918, %870 ], [ %862, %861 ]
  %923 = phi float [ %919, %870 ], [ %863, %861 ]
  %924 = phi float [ %920, %870 ], [ %864, %861 ]
  %925 = or i32 %144, 13
  %926 = add i32 %925, %53
  %927 = icmp ne i32 %926, %17
  %928 = icmp slt i32 %926, 4096
  %929 = and i1 %927, %928
  br i1 %929, label %930, label %981

930:                                              ; preds = %921
  %931 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %925, i32 0, i32 0, i32 0
  %932 = load <4 x float>, <4 x float> addrspace(3)* %931, align 16
  %933 = extractelement <4 x float> %932, i64 0
  %934 = fsub contract float %933, %20
  %935 = extractelement <4 x float> %932, i64 1
  %936 = fsub contract float %935, %22
  %937 = extractelement <4 x float> %932, i64 2
  %938 = fsub contract float %937, %24
  %939 = fmul contract float %934, %934
  %940 = fmul contract float %936, %936
  %941 = fadd contract float %939, %940
  %942 = fmul contract float %938, %938
  %943 = fadd contract float %942, %941
  %944 = fcmp olt float %943, 0x39F0000000000000
  %945 = select i1 %944, float 0x41F0000000000000, float 1.000000e+00
  %946 = fmul float %943, %945
  %947 = tail call float @llvm.sqrt.f32(float %946)
  %948 = bitcast float %947 to i32
  %949 = add nsw i32 %948, -1
  %950 = bitcast i32 %949 to float
  %951 = add nsw i32 %948, 1
  %952 = bitcast i32 %951 to float
  %953 = tail call i1 @llvm.amdgcn.class.f32(float %946, i32 608)
  %954 = select i1 %944, float 0x3EF0000000000000, float 1.000000e+00
  %955 = fneg float %952
  %956 = tail call float @llvm.fma.f32(float %955, float %947, float %946)
  %957 = fcmp ogt float %956, 0.000000e+00
  %958 = fneg float %950
  %959 = tail call float @llvm.fma.f32(float %958, float %947, float %946)
  %960 = fcmp ole float %959, 0.000000e+00
  %961 = select i1 %960, float %950, float %947
  %962 = select i1 %957, float %952, float %961
  %963 = fmul float %954, %962
  %964 = select i1 %953, float %946, float %963
  %965 = fdiv contract float 1.000000e+00, %964
  %966 = extractelement <4 x float> %932, i64 3
  %967 = fpext float %966 to double
  %968 = fmul contract double %38, %967
  %969 = fpext float %943 to double
  %970 = fdiv contract double %968, %969
  %971 = fptrunc double %970 to float
  %972 = fmul contract float %934, %971
  %973 = fmul contract float %972, %965
  %974 = fmul contract float %936, %971
  %975 = fmul contract float %974, %965
  %976 = fmul contract float %938, %971
  %977 = fmul contract float %976, %965
  %978 = fadd contract float %922, %973
  %979 = fadd contract float %923, %975
  %980 = fadd contract float %924, %977
  br label %981

981:                                              ; preds = %930, %921
  %982 = phi float [ %978, %930 ], [ %922, %921 ]
  %983 = phi float [ %979, %930 ], [ %923, %921 ]
  %984 = phi float [ %980, %930 ], [ %924, %921 ]
  %985 = or i32 %144, 14
  %986 = add i32 %985, %53
  %987 = icmp ne i32 %986, %17
  %988 = icmp slt i32 %986, 4096
  %989 = and i1 %987, %988
  br i1 %989, label %990, label %1041

990:                                              ; preds = %981
  %991 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %985, i32 0, i32 0, i32 0
  %992 = load <4 x float>, <4 x float> addrspace(3)* %991, align 16
  %993 = extractelement <4 x float> %992, i64 0
  %994 = fsub contract float %993, %20
  %995 = extractelement <4 x float> %992, i64 1
  %996 = fsub contract float %995, %22
  %997 = extractelement <4 x float> %992, i64 2
  %998 = fsub contract float %997, %24
  %999 = fmul contract float %994, %994
  %1000 = fmul contract float %996, %996
  %1001 = fadd contract float %999, %1000
  %1002 = fmul contract float %998, %998
  %1003 = fadd contract float %1002, %1001
  %1004 = fcmp olt float %1003, 0x39F0000000000000
  %1005 = select i1 %1004, float 0x41F0000000000000, float 1.000000e+00
  %1006 = fmul float %1003, %1005
  %1007 = tail call float @llvm.sqrt.f32(float %1006)
  %1008 = bitcast float %1007 to i32
  %1009 = add nsw i32 %1008, -1
  %1010 = bitcast i32 %1009 to float
  %1011 = add nsw i32 %1008, 1
  %1012 = bitcast i32 %1011 to float
  %1013 = tail call i1 @llvm.amdgcn.class.f32(float %1006, i32 608)
  %1014 = select i1 %1004, float 0x3EF0000000000000, float 1.000000e+00
  %1015 = fneg float %1012
  %1016 = tail call float @llvm.fma.f32(float %1015, float %1007, float %1006)
  %1017 = fcmp ogt float %1016, 0.000000e+00
  %1018 = fneg float %1010
  %1019 = tail call float @llvm.fma.f32(float %1018, float %1007, float %1006)
  %1020 = fcmp ole float %1019, 0.000000e+00
  %1021 = select i1 %1020, float %1010, float %1007
  %1022 = select i1 %1017, float %1012, float %1021
  %1023 = fmul float %1014, %1022
  %1024 = select i1 %1013, float %1006, float %1023
  %1025 = fdiv contract float 1.000000e+00, %1024
  %1026 = extractelement <4 x float> %992, i64 3
  %1027 = fpext float %1026 to double
  %1028 = fmul contract double %38, %1027
  %1029 = fpext float %1003 to double
  %1030 = fdiv contract double %1028, %1029
  %1031 = fptrunc double %1030 to float
  %1032 = fmul contract float %994, %1031
  %1033 = fmul contract float %1032, %1025
  %1034 = fmul contract float %996, %1031
  %1035 = fmul contract float %1034, %1025
  %1036 = fmul contract float %998, %1031
  %1037 = fmul contract float %1036, %1025
  %1038 = fadd contract float %982, %1033
  %1039 = fadd contract float %983, %1035
  %1040 = fadd contract float %984, %1037
  br label %1041

1041:                                             ; preds = %990, %981
  %1042 = phi float [ %1038, %990 ], [ %982, %981 ]
  %1043 = phi float [ %1039, %990 ], [ %983, %981 ]
  %1044 = phi float [ %1040, %990 ], [ %984, %981 ]
  %1045 = or i32 %144, 15
  %1046 = add i32 %1045, %53
  %1047 = icmp ne i32 %1046, %17
  %1048 = icmp slt i32 %1046, 4096
  %1049 = and i1 %1047, %1048
  br i1 %1049, label %1050, label %1101

1050:                                             ; preds = %1041
  %1051 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1045, i32 0, i32 0, i32 0
  %1052 = load <4 x float>, <4 x float> addrspace(3)* %1051, align 16
  %1053 = extractelement <4 x float> %1052, i64 0
  %1054 = fsub contract float %1053, %20
  %1055 = extractelement <4 x float> %1052, i64 1
  %1056 = fsub contract float %1055, %22
  %1057 = extractelement <4 x float> %1052, i64 2
  %1058 = fsub contract float %1057, %24
  %1059 = fmul contract float %1054, %1054
  %1060 = fmul contract float %1056, %1056
  %1061 = fadd contract float %1059, %1060
  %1062 = fmul contract float %1058, %1058
  %1063 = fadd contract float %1062, %1061
  %1064 = fcmp olt float %1063, 0x39F0000000000000
  %1065 = select i1 %1064, float 0x41F0000000000000, float 1.000000e+00
  %1066 = fmul float %1063, %1065
  %1067 = tail call float @llvm.sqrt.f32(float %1066)
  %1068 = bitcast float %1067 to i32
  %1069 = add nsw i32 %1068, -1
  %1070 = bitcast i32 %1069 to float
  %1071 = add nsw i32 %1068, 1
  %1072 = bitcast i32 %1071 to float
  %1073 = tail call i1 @llvm.amdgcn.class.f32(float %1066, i32 608)
  %1074 = select i1 %1064, float 0x3EF0000000000000, float 1.000000e+00
  %1075 = fneg float %1072
  %1076 = tail call float @llvm.fma.f32(float %1075, float %1067, float %1066)
  %1077 = fcmp ogt float %1076, 0.000000e+00
  %1078 = fneg float %1070
  %1079 = tail call float @llvm.fma.f32(float %1078, float %1067, float %1066)
  %1080 = fcmp ole float %1079, 0.000000e+00
  %1081 = select i1 %1080, float %1070, float %1067
  %1082 = select i1 %1077, float %1072, float %1081
  %1083 = fmul float %1074, %1082
  %1084 = select i1 %1073, float %1066, float %1083
  %1085 = fdiv contract float 1.000000e+00, %1084
  %1086 = extractelement <4 x float> %1052, i64 3
  %1087 = fpext float %1086 to double
  %1088 = fmul contract double %38, %1087
  %1089 = fpext float %1063 to double
  %1090 = fdiv contract double %1088, %1089
  %1091 = fptrunc double %1090 to float
  %1092 = fmul contract float %1054, %1091
  %1093 = fmul contract float %1092, %1085
  %1094 = fmul contract float %1056, %1091
  %1095 = fmul contract float %1094, %1085
  %1096 = fmul contract float %1058, %1091
  %1097 = fmul contract float %1096, %1085
  %1098 = fadd contract float %1042, %1093
  %1099 = fadd contract float %1043, %1095
  %1100 = fadd contract float %1044, %1097
  br label %1101

1101:                                             ; preds = %1050, %1041
  %1102 = phi float [ %1098, %1050 ], [ %1042, %1041 ]
  %1103 = phi float [ %1099, %1050 ], [ %1043, %1041 ]
  %1104 = phi float [ %1100, %1050 ], [ %1044, %1041 ]
  %1105 = or i32 %144, 16
  %1106 = add i32 %1105, %53
  %1107 = icmp ne i32 %1106, %17
  %1108 = icmp slt i32 %1106, 4096
  %1109 = and i1 %1107, %1108
  br i1 %1109, label %1110, label %1161

1110:                                             ; preds = %1101
  %1111 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1105, i32 0, i32 0, i32 0
  %1112 = load <4 x float>, <4 x float> addrspace(3)* %1111, align 16
  %1113 = extractelement <4 x float> %1112, i64 0
  %1114 = fsub contract float %1113, %20
  %1115 = extractelement <4 x float> %1112, i64 1
  %1116 = fsub contract float %1115, %22
  %1117 = extractelement <4 x float> %1112, i64 2
  %1118 = fsub contract float %1117, %24
  %1119 = fmul contract float %1114, %1114
  %1120 = fmul contract float %1116, %1116
  %1121 = fadd contract float %1119, %1120
  %1122 = fmul contract float %1118, %1118
  %1123 = fadd contract float %1122, %1121
  %1124 = fcmp olt float %1123, 0x39F0000000000000
  %1125 = select i1 %1124, float 0x41F0000000000000, float 1.000000e+00
  %1126 = fmul float %1123, %1125
  %1127 = tail call float @llvm.sqrt.f32(float %1126)
  %1128 = bitcast float %1127 to i32
  %1129 = add nsw i32 %1128, -1
  %1130 = bitcast i32 %1129 to float
  %1131 = add nsw i32 %1128, 1
  %1132 = bitcast i32 %1131 to float
  %1133 = tail call i1 @llvm.amdgcn.class.f32(float %1126, i32 608)
  %1134 = select i1 %1124, float 0x3EF0000000000000, float 1.000000e+00
  %1135 = fneg float %1132
  %1136 = tail call float @llvm.fma.f32(float %1135, float %1127, float %1126)
  %1137 = fcmp ogt float %1136, 0.000000e+00
  %1138 = fneg float %1130
  %1139 = tail call float @llvm.fma.f32(float %1138, float %1127, float %1126)
  %1140 = fcmp ole float %1139, 0.000000e+00
  %1141 = select i1 %1140, float %1130, float %1127
  %1142 = select i1 %1137, float %1132, float %1141
  %1143 = fmul float %1134, %1142
  %1144 = select i1 %1133, float %1126, float %1143
  %1145 = fdiv contract float 1.000000e+00, %1144
  %1146 = extractelement <4 x float> %1112, i64 3
  %1147 = fpext float %1146 to double
  %1148 = fmul contract double %38, %1147
  %1149 = fpext float %1123 to double
  %1150 = fdiv contract double %1148, %1149
  %1151 = fptrunc double %1150 to float
  %1152 = fmul contract float %1114, %1151
  %1153 = fmul contract float %1152, %1145
  %1154 = fmul contract float %1116, %1151
  %1155 = fmul contract float %1154, %1145
  %1156 = fmul contract float %1118, %1151
  %1157 = fmul contract float %1156, %1145
  %1158 = fadd contract float %1102, %1153
  %1159 = fadd contract float %1103, %1155
  %1160 = fadd contract float %1104, %1157
  br label %1161

1161:                                             ; preds = %1110, %1101
  %1162 = phi float [ %1158, %1110 ], [ %1102, %1101 ]
  %1163 = phi float [ %1159, %1110 ], [ %1103, %1101 ]
  %1164 = phi float [ %1160, %1110 ], [ %1104, %1101 ]
  %1165 = or i32 %144, 17
  %1166 = add i32 %1165, %53
  %1167 = icmp ne i32 %1166, %17
  %1168 = icmp slt i32 %1166, 4096
  %1169 = and i1 %1167, %1168
  br i1 %1169, label %1170, label %1221

1170:                                             ; preds = %1161
  %1171 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1165, i32 0, i32 0, i32 0
  %1172 = load <4 x float>, <4 x float> addrspace(3)* %1171, align 16
  %1173 = extractelement <4 x float> %1172, i64 0
  %1174 = fsub contract float %1173, %20
  %1175 = extractelement <4 x float> %1172, i64 1
  %1176 = fsub contract float %1175, %22
  %1177 = extractelement <4 x float> %1172, i64 2
  %1178 = fsub contract float %1177, %24
  %1179 = fmul contract float %1174, %1174
  %1180 = fmul contract float %1176, %1176
  %1181 = fadd contract float %1179, %1180
  %1182 = fmul contract float %1178, %1178
  %1183 = fadd contract float %1182, %1181
  %1184 = fcmp olt float %1183, 0x39F0000000000000
  %1185 = select i1 %1184, float 0x41F0000000000000, float 1.000000e+00
  %1186 = fmul float %1183, %1185
  %1187 = tail call float @llvm.sqrt.f32(float %1186)
  %1188 = bitcast float %1187 to i32
  %1189 = add nsw i32 %1188, -1
  %1190 = bitcast i32 %1189 to float
  %1191 = add nsw i32 %1188, 1
  %1192 = bitcast i32 %1191 to float
  %1193 = tail call i1 @llvm.amdgcn.class.f32(float %1186, i32 608)
  %1194 = select i1 %1184, float 0x3EF0000000000000, float 1.000000e+00
  %1195 = fneg float %1192
  %1196 = tail call float @llvm.fma.f32(float %1195, float %1187, float %1186)
  %1197 = fcmp ogt float %1196, 0.000000e+00
  %1198 = fneg float %1190
  %1199 = tail call float @llvm.fma.f32(float %1198, float %1187, float %1186)
  %1200 = fcmp ole float %1199, 0.000000e+00
  %1201 = select i1 %1200, float %1190, float %1187
  %1202 = select i1 %1197, float %1192, float %1201
  %1203 = fmul float %1194, %1202
  %1204 = select i1 %1193, float %1186, float %1203
  %1205 = fdiv contract float 1.000000e+00, %1204
  %1206 = extractelement <4 x float> %1172, i64 3
  %1207 = fpext float %1206 to double
  %1208 = fmul contract double %38, %1207
  %1209 = fpext float %1183 to double
  %1210 = fdiv contract double %1208, %1209
  %1211 = fptrunc double %1210 to float
  %1212 = fmul contract float %1174, %1211
  %1213 = fmul contract float %1212, %1205
  %1214 = fmul contract float %1176, %1211
  %1215 = fmul contract float %1214, %1205
  %1216 = fmul contract float %1178, %1211
  %1217 = fmul contract float %1216, %1205
  %1218 = fadd contract float %1162, %1213
  %1219 = fadd contract float %1163, %1215
  %1220 = fadd contract float %1164, %1217
  br label %1221

1221:                                             ; preds = %1170, %1161
  %1222 = phi float [ %1218, %1170 ], [ %1162, %1161 ]
  %1223 = phi float [ %1219, %1170 ], [ %1163, %1161 ]
  %1224 = phi float [ %1220, %1170 ], [ %1164, %1161 ]
  %1225 = or i32 %144, 18
  %1226 = add i32 %1225, %53
  %1227 = icmp ne i32 %1226, %17
  %1228 = icmp slt i32 %1226, 4096
  %1229 = and i1 %1227, %1228
  br i1 %1229, label %1230, label %1281

1230:                                             ; preds = %1221
  %1231 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1225, i32 0, i32 0, i32 0
  %1232 = load <4 x float>, <4 x float> addrspace(3)* %1231, align 16
  %1233 = extractelement <4 x float> %1232, i64 0
  %1234 = fsub contract float %1233, %20
  %1235 = extractelement <4 x float> %1232, i64 1
  %1236 = fsub contract float %1235, %22
  %1237 = extractelement <4 x float> %1232, i64 2
  %1238 = fsub contract float %1237, %24
  %1239 = fmul contract float %1234, %1234
  %1240 = fmul contract float %1236, %1236
  %1241 = fadd contract float %1239, %1240
  %1242 = fmul contract float %1238, %1238
  %1243 = fadd contract float %1242, %1241
  %1244 = fcmp olt float %1243, 0x39F0000000000000
  %1245 = select i1 %1244, float 0x41F0000000000000, float 1.000000e+00
  %1246 = fmul float %1243, %1245
  %1247 = tail call float @llvm.sqrt.f32(float %1246)
  %1248 = bitcast float %1247 to i32
  %1249 = add nsw i32 %1248, -1
  %1250 = bitcast i32 %1249 to float
  %1251 = add nsw i32 %1248, 1
  %1252 = bitcast i32 %1251 to float
  %1253 = tail call i1 @llvm.amdgcn.class.f32(float %1246, i32 608)
  %1254 = select i1 %1244, float 0x3EF0000000000000, float 1.000000e+00
  %1255 = fneg float %1252
  %1256 = tail call float @llvm.fma.f32(float %1255, float %1247, float %1246)
  %1257 = fcmp ogt float %1256, 0.000000e+00
  %1258 = fneg float %1250
  %1259 = tail call float @llvm.fma.f32(float %1258, float %1247, float %1246)
  %1260 = fcmp ole float %1259, 0.000000e+00
  %1261 = select i1 %1260, float %1250, float %1247
  %1262 = select i1 %1257, float %1252, float %1261
  %1263 = fmul float %1254, %1262
  %1264 = select i1 %1253, float %1246, float %1263
  %1265 = fdiv contract float 1.000000e+00, %1264
  %1266 = extractelement <4 x float> %1232, i64 3
  %1267 = fpext float %1266 to double
  %1268 = fmul contract double %38, %1267
  %1269 = fpext float %1243 to double
  %1270 = fdiv contract double %1268, %1269
  %1271 = fptrunc double %1270 to float
  %1272 = fmul contract float %1234, %1271
  %1273 = fmul contract float %1272, %1265
  %1274 = fmul contract float %1236, %1271
  %1275 = fmul contract float %1274, %1265
  %1276 = fmul contract float %1238, %1271
  %1277 = fmul contract float %1276, %1265
  %1278 = fadd contract float %1222, %1273
  %1279 = fadd contract float %1223, %1275
  %1280 = fadd contract float %1224, %1277
  br label %1281

1281:                                             ; preds = %1230, %1221
  %1282 = phi float [ %1278, %1230 ], [ %1222, %1221 ]
  %1283 = phi float [ %1279, %1230 ], [ %1223, %1221 ]
  %1284 = phi float [ %1280, %1230 ], [ %1224, %1221 ]
  %1285 = or i32 %144, 19
  %1286 = add i32 %1285, %53
  %1287 = icmp ne i32 %1286, %17
  %1288 = icmp slt i32 %1286, 4096
  %1289 = and i1 %1287, %1288
  br i1 %1289, label %1290, label %1341

1290:                                             ; preds = %1281
  %1291 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1285, i32 0, i32 0, i32 0
  %1292 = load <4 x float>, <4 x float> addrspace(3)* %1291, align 16
  %1293 = extractelement <4 x float> %1292, i64 0
  %1294 = fsub contract float %1293, %20
  %1295 = extractelement <4 x float> %1292, i64 1
  %1296 = fsub contract float %1295, %22
  %1297 = extractelement <4 x float> %1292, i64 2
  %1298 = fsub contract float %1297, %24
  %1299 = fmul contract float %1294, %1294
  %1300 = fmul contract float %1296, %1296
  %1301 = fadd contract float %1299, %1300
  %1302 = fmul contract float %1298, %1298
  %1303 = fadd contract float %1302, %1301
  %1304 = fcmp olt float %1303, 0x39F0000000000000
  %1305 = select i1 %1304, float 0x41F0000000000000, float 1.000000e+00
  %1306 = fmul float %1303, %1305
  %1307 = tail call float @llvm.sqrt.f32(float %1306)
  %1308 = bitcast float %1307 to i32
  %1309 = add nsw i32 %1308, -1
  %1310 = bitcast i32 %1309 to float
  %1311 = add nsw i32 %1308, 1
  %1312 = bitcast i32 %1311 to float
  %1313 = tail call i1 @llvm.amdgcn.class.f32(float %1306, i32 608)
  %1314 = select i1 %1304, float 0x3EF0000000000000, float 1.000000e+00
  %1315 = fneg float %1312
  %1316 = tail call float @llvm.fma.f32(float %1315, float %1307, float %1306)
  %1317 = fcmp ogt float %1316, 0.000000e+00
  %1318 = fneg float %1310
  %1319 = tail call float @llvm.fma.f32(float %1318, float %1307, float %1306)
  %1320 = fcmp ole float %1319, 0.000000e+00
  %1321 = select i1 %1320, float %1310, float %1307
  %1322 = select i1 %1317, float %1312, float %1321
  %1323 = fmul float %1314, %1322
  %1324 = select i1 %1313, float %1306, float %1323
  %1325 = fdiv contract float 1.000000e+00, %1324
  %1326 = extractelement <4 x float> %1292, i64 3
  %1327 = fpext float %1326 to double
  %1328 = fmul contract double %38, %1327
  %1329 = fpext float %1303 to double
  %1330 = fdiv contract double %1328, %1329
  %1331 = fptrunc double %1330 to float
  %1332 = fmul contract float %1294, %1331
  %1333 = fmul contract float %1332, %1325
  %1334 = fmul contract float %1296, %1331
  %1335 = fmul contract float %1334, %1325
  %1336 = fmul contract float %1298, %1331
  %1337 = fmul contract float %1336, %1325
  %1338 = fadd contract float %1282, %1333
  %1339 = fadd contract float %1283, %1335
  %1340 = fadd contract float %1284, %1337
  br label %1341

1341:                                             ; preds = %1290, %1281
  %1342 = phi float [ %1338, %1290 ], [ %1282, %1281 ]
  %1343 = phi float [ %1339, %1290 ], [ %1283, %1281 ]
  %1344 = phi float [ %1340, %1290 ], [ %1284, %1281 ]
  %1345 = or i32 %144, 20
  %1346 = add i32 %1345, %53
  %1347 = icmp ne i32 %1346, %17
  %1348 = icmp slt i32 %1346, 4096
  %1349 = and i1 %1347, %1348
  br i1 %1349, label %1350, label %1401

1350:                                             ; preds = %1341
  %1351 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1345, i32 0, i32 0, i32 0
  %1352 = load <4 x float>, <4 x float> addrspace(3)* %1351, align 16
  %1353 = extractelement <4 x float> %1352, i64 0
  %1354 = fsub contract float %1353, %20
  %1355 = extractelement <4 x float> %1352, i64 1
  %1356 = fsub contract float %1355, %22
  %1357 = extractelement <4 x float> %1352, i64 2
  %1358 = fsub contract float %1357, %24
  %1359 = fmul contract float %1354, %1354
  %1360 = fmul contract float %1356, %1356
  %1361 = fadd contract float %1359, %1360
  %1362 = fmul contract float %1358, %1358
  %1363 = fadd contract float %1362, %1361
  %1364 = fcmp olt float %1363, 0x39F0000000000000
  %1365 = select i1 %1364, float 0x41F0000000000000, float 1.000000e+00
  %1366 = fmul float %1363, %1365
  %1367 = tail call float @llvm.sqrt.f32(float %1366)
  %1368 = bitcast float %1367 to i32
  %1369 = add nsw i32 %1368, -1
  %1370 = bitcast i32 %1369 to float
  %1371 = add nsw i32 %1368, 1
  %1372 = bitcast i32 %1371 to float
  %1373 = tail call i1 @llvm.amdgcn.class.f32(float %1366, i32 608)
  %1374 = select i1 %1364, float 0x3EF0000000000000, float 1.000000e+00
  %1375 = fneg float %1372
  %1376 = tail call float @llvm.fma.f32(float %1375, float %1367, float %1366)
  %1377 = fcmp ogt float %1376, 0.000000e+00
  %1378 = fneg float %1370
  %1379 = tail call float @llvm.fma.f32(float %1378, float %1367, float %1366)
  %1380 = fcmp ole float %1379, 0.000000e+00
  %1381 = select i1 %1380, float %1370, float %1367
  %1382 = select i1 %1377, float %1372, float %1381
  %1383 = fmul float %1374, %1382
  %1384 = select i1 %1373, float %1366, float %1383
  %1385 = fdiv contract float 1.000000e+00, %1384
  %1386 = extractelement <4 x float> %1352, i64 3
  %1387 = fpext float %1386 to double
  %1388 = fmul contract double %38, %1387
  %1389 = fpext float %1363 to double
  %1390 = fdiv contract double %1388, %1389
  %1391 = fptrunc double %1390 to float
  %1392 = fmul contract float %1354, %1391
  %1393 = fmul contract float %1392, %1385
  %1394 = fmul contract float %1356, %1391
  %1395 = fmul contract float %1394, %1385
  %1396 = fmul contract float %1358, %1391
  %1397 = fmul contract float %1396, %1385
  %1398 = fadd contract float %1342, %1393
  %1399 = fadd contract float %1343, %1395
  %1400 = fadd contract float %1344, %1397
  br label %1401

1401:                                             ; preds = %1350, %1341
  %1402 = phi float [ %1398, %1350 ], [ %1342, %1341 ]
  %1403 = phi float [ %1399, %1350 ], [ %1343, %1341 ]
  %1404 = phi float [ %1400, %1350 ], [ %1344, %1341 ]
  %1405 = or i32 %144, 21
  %1406 = add i32 %1405, %53
  %1407 = icmp ne i32 %1406, %17
  %1408 = icmp slt i32 %1406, 4096
  %1409 = and i1 %1407, %1408
  br i1 %1409, label %1410, label %1461

1410:                                             ; preds = %1401
  %1411 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1405, i32 0, i32 0, i32 0
  %1412 = load <4 x float>, <4 x float> addrspace(3)* %1411, align 16
  %1413 = extractelement <4 x float> %1412, i64 0
  %1414 = fsub contract float %1413, %20
  %1415 = extractelement <4 x float> %1412, i64 1
  %1416 = fsub contract float %1415, %22
  %1417 = extractelement <4 x float> %1412, i64 2
  %1418 = fsub contract float %1417, %24
  %1419 = fmul contract float %1414, %1414
  %1420 = fmul contract float %1416, %1416
  %1421 = fadd contract float %1419, %1420
  %1422 = fmul contract float %1418, %1418
  %1423 = fadd contract float %1422, %1421
  %1424 = fcmp olt float %1423, 0x39F0000000000000
  %1425 = select i1 %1424, float 0x41F0000000000000, float 1.000000e+00
  %1426 = fmul float %1423, %1425
  %1427 = tail call float @llvm.sqrt.f32(float %1426)
  %1428 = bitcast float %1427 to i32
  %1429 = add nsw i32 %1428, -1
  %1430 = bitcast i32 %1429 to float
  %1431 = add nsw i32 %1428, 1
  %1432 = bitcast i32 %1431 to float
  %1433 = tail call i1 @llvm.amdgcn.class.f32(float %1426, i32 608)
  %1434 = select i1 %1424, float 0x3EF0000000000000, float 1.000000e+00
  %1435 = fneg float %1432
  %1436 = tail call float @llvm.fma.f32(float %1435, float %1427, float %1426)
  %1437 = fcmp ogt float %1436, 0.000000e+00
  %1438 = fneg float %1430
  %1439 = tail call float @llvm.fma.f32(float %1438, float %1427, float %1426)
  %1440 = fcmp ole float %1439, 0.000000e+00
  %1441 = select i1 %1440, float %1430, float %1427
  %1442 = select i1 %1437, float %1432, float %1441
  %1443 = fmul float %1434, %1442
  %1444 = select i1 %1433, float %1426, float %1443
  %1445 = fdiv contract float 1.000000e+00, %1444
  %1446 = extractelement <4 x float> %1412, i64 3
  %1447 = fpext float %1446 to double
  %1448 = fmul contract double %38, %1447
  %1449 = fpext float %1423 to double
  %1450 = fdiv contract double %1448, %1449
  %1451 = fptrunc double %1450 to float
  %1452 = fmul contract float %1414, %1451
  %1453 = fmul contract float %1452, %1445
  %1454 = fmul contract float %1416, %1451
  %1455 = fmul contract float %1454, %1445
  %1456 = fmul contract float %1418, %1451
  %1457 = fmul contract float %1456, %1445
  %1458 = fadd contract float %1402, %1453
  %1459 = fadd contract float %1403, %1455
  %1460 = fadd contract float %1404, %1457
  br label %1461

1461:                                             ; preds = %1410, %1401
  %1462 = phi float [ %1458, %1410 ], [ %1402, %1401 ]
  %1463 = phi float [ %1459, %1410 ], [ %1403, %1401 ]
  %1464 = phi float [ %1460, %1410 ], [ %1404, %1401 ]
  %1465 = or i32 %144, 22
  %1466 = add i32 %1465, %53
  %1467 = icmp ne i32 %1466, %17
  %1468 = icmp slt i32 %1466, 4096
  %1469 = and i1 %1467, %1468
  br i1 %1469, label %1470, label %1521

1470:                                             ; preds = %1461
  %1471 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1465, i32 0, i32 0, i32 0
  %1472 = load <4 x float>, <4 x float> addrspace(3)* %1471, align 16
  %1473 = extractelement <4 x float> %1472, i64 0
  %1474 = fsub contract float %1473, %20
  %1475 = extractelement <4 x float> %1472, i64 1
  %1476 = fsub contract float %1475, %22
  %1477 = extractelement <4 x float> %1472, i64 2
  %1478 = fsub contract float %1477, %24
  %1479 = fmul contract float %1474, %1474
  %1480 = fmul contract float %1476, %1476
  %1481 = fadd contract float %1479, %1480
  %1482 = fmul contract float %1478, %1478
  %1483 = fadd contract float %1482, %1481
  %1484 = fcmp olt float %1483, 0x39F0000000000000
  %1485 = select i1 %1484, float 0x41F0000000000000, float 1.000000e+00
  %1486 = fmul float %1483, %1485
  %1487 = tail call float @llvm.sqrt.f32(float %1486)
  %1488 = bitcast float %1487 to i32
  %1489 = add nsw i32 %1488, -1
  %1490 = bitcast i32 %1489 to float
  %1491 = add nsw i32 %1488, 1
  %1492 = bitcast i32 %1491 to float
  %1493 = tail call i1 @llvm.amdgcn.class.f32(float %1486, i32 608)
  %1494 = select i1 %1484, float 0x3EF0000000000000, float 1.000000e+00
  %1495 = fneg float %1492
  %1496 = tail call float @llvm.fma.f32(float %1495, float %1487, float %1486)
  %1497 = fcmp ogt float %1496, 0.000000e+00
  %1498 = fneg float %1490
  %1499 = tail call float @llvm.fma.f32(float %1498, float %1487, float %1486)
  %1500 = fcmp ole float %1499, 0.000000e+00
  %1501 = select i1 %1500, float %1490, float %1487
  %1502 = select i1 %1497, float %1492, float %1501
  %1503 = fmul float %1494, %1502
  %1504 = select i1 %1493, float %1486, float %1503
  %1505 = fdiv contract float 1.000000e+00, %1504
  %1506 = extractelement <4 x float> %1472, i64 3
  %1507 = fpext float %1506 to double
  %1508 = fmul contract double %38, %1507
  %1509 = fpext float %1483 to double
  %1510 = fdiv contract double %1508, %1509
  %1511 = fptrunc double %1510 to float
  %1512 = fmul contract float %1474, %1511
  %1513 = fmul contract float %1512, %1505
  %1514 = fmul contract float %1476, %1511
  %1515 = fmul contract float %1514, %1505
  %1516 = fmul contract float %1478, %1511
  %1517 = fmul contract float %1516, %1505
  %1518 = fadd contract float %1462, %1513
  %1519 = fadd contract float %1463, %1515
  %1520 = fadd contract float %1464, %1517
  br label %1521

1521:                                             ; preds = %1470, %1461
  %1522 = phi float [ %1518, %1470 ], [ %1462, %1461 ]
  %1523 = phi float [ %1519, %1470 ], [ %1463, %1461 ]
  %1524 = phi float [ %1520, %1470 ], [ %1464, %1461 ]
  %1525 = or i32 %144, 23
  %1526 = add i32 %1525, %53
  %1527 = icmp ne i32 %1526, %17
  %1528 = icmp slt i32 %1526, 4096
  %1529 = and i1 %1527, %1528
  br i1 %1529, label %1530, label %1581

1530:                                             ; preds = %1521
  %1531 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1525, i32 0, i32 0, i32 0
  %1532 = load <4 x float>, <4 x float> addrspace(3)* %1531, align 16
  %1533 = extractelement <4 x float> %1532, i64 0
  %1534 = fsub contract float %1533, %20
  %1535 = extractelement <4 x float> %1532, i64 1
  %1536 = fsub contract float %1535, %22
  %1537 = extractelement <4 x float> %1532, i64 2
  %1538 = fsub contract float %1537, %24
  %1539 = fmul contract float %1534, %1534
  %1540 = fmul contract float %1536, %1536
  %1541 = fadd contract float %1539, %1540
  %1542 = fmul contract float %1538, %1538
  %1543 = fadd contract float %1542, %1541
  %1544 = fcmp olt float %1543, 0x39F0000000000000
  %1545 = select i1 %1544, float 0x41F0000000000000, float 1.000000e+00
  %1546 = fmul float %1543, %1545
  %1547 = tail call float @llvm.sqrt.f32(float %1546)
  %1548 = bitcast float %1547 to i32
  %1549 = add nsw i32 %1548, -1
  %1550 = bitcast i32 %1549 to float
  %1551 = add nsw i32 %1548, 1
  %1552 = bitcast i32 %1551 to float
  %1553 = tail call i1 @llvm.amdgcn.class.f32(float %1546, i32 608)
  %1554 = select i1 %1544, float 0x3EF0000000000000, float 1.000000e+00
  %1555 = fneg float %1552
  %1556 = tail call float @llvm.fma.f32(float %1555, float %1547, float %1546)
  %1557 = fcmp ogt float %1556, 0.000000e+00
  %1558 = fneg float %1550
  %1559 = tail call float @llvm.fma.f32(float %1558, float %1547, float %1546)
  %1560 = fcmp ole float %1559, 0.000000e+00
  %1561 = select i1 %1560, float %1550, float %1547
  %1562 = select i1 %1557, float %1552, float %1561
  %1563 = fmul float %1554, %1562
  %1564 = select i1 %1553, float %1546, float %1563
  %1565 = fdiv contract float 1.000000e+00, %1564
  %1566 = extractelement <4 x float> %1532, i64 3
  %1567 = fpext float %1566 to double
  %1568 = fmul contract double %38, %1567
  %1569 = fpext float %1543 to double
  %1570 = fdiv contract double %1568, %1569
  %1571 = fptrunc double %1570 to float
  %1572 = fmul contract float %1534, %1571
  %1573 = fmul contract float %1572, %1565
  %1574 = fmul contract float %1536, %1571
  %1575 = fmul contract float %1574, %1565
  %1576 = fmul contract float %1538, %1571
  %1577 = fmul contract float %1576, %1565
  %1578 = fadd contract float %1522, %1573
  %1579 = fadd contract float %1523, %1575
  %1580 = fadd contract float %1524, %1577
  br label %1581

1581:                                             ; preds = %1530, %1521
  %1582 = phi float [ %1578, %1530 ], [ %1522, %1521 ]
  %1583 = phi float [ %1579, %1530 ], [ %1523, %1521 ]
  %1584 = phi float [ %1580, %1530 ], [ %1524, %1521 ]
  %1585 = or i32 %144, 24
  %1586 = add i32 %1585, %53
  %1587 = icmp ne i32 %1586, %17
  %1588 = icmp slt i32 %1586, 4096
  %1589 = and i1 %1587, %1588
  br i1 %1589, label %1590, label %1641

1590:                                             ; preds = %1581
  %1591 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1585, i32 0, i32 0, i32 0
  %1592 = load <4 x float>, <4 x float> addrspace(3)* %1591, align 16
  %1593 = extractelement <4 x float> %1592, i64 0
  %1594 = fsub contract float %1593, %20
  %1595 = extractelement <4 x float> %1592, i64 1
  %1596 = fsub contract float %1595, %22
  %1597 = extractelement <4 x float> %1592, i64 2
  %1598 = fsub contract float %1597, %24
  %1599 = fmul contract float %1594, %1594
  %1600 = fmul contract float %1596, %1596
  %1601 = fadd contract float %1599, %1600
  %1602 = fmul contract float %1598, %1598
  %1603 = fadd contract float %1602, %1601
  %1604 = fcmp olt float %1603, 0x39F0000000000000
  %1605 = select i1 %1604, float 0x41F0000000000000, float 1.000000e+00
  %1606 = fmul float %1603, %1605
  %1607 = tail call float @llvm.sqrt.f32(float %1606)
  %1608 = bitcast float %1607 to i32
  %1609 = add nsw i32 %1608, -1
  %1610 = bitcast i32 %1609 to float
  %1611 = add nsw i32 %1608, 1
  %1612 = bitcast i32 %1611 to float
  %1613 = tail call i1 @llvm.amdgcn.class.f32(float %1606, i32 608)
  %1614 = select i1 %1604, float 0x3EF0000000000000, float 1.000000e+00
  %1615 = fneg float %1612
  %1616 = tail call float @llvm.fma.f32(float %1615, float %1607, float %1606)
  %1617 = fcmp ogt float %1616, 0.000000e+00
  %1618 = fneg float %1610
  %1619 = tail call float @llvm.fma.f32(float %1618, float %1607, float %1606)
  %1620 = fcmp ole float %1619, 0.000000e+00
  %1621 = select i1 %1620, float %1610, float %1607
  %1622 = select i1 %1617, float %1612, float %1621
  %1623 = fmul float %1614, %1622
  %1624 = select i1 %1613, float %1606, float %1623
  %1625 = fdiv contract float 1.000000e+00, %1624
  %1626 = extractelement <4 x float> %1592, i64 3
  %1627 = fpext float %1626 to double
  %1628 = fmul contract double %38, %1627
  %1629 = fpext float %1603 to double
  %1630 = fdiv contract double %1628, %1629
  %1631 = fptrunc double %1630 to float
  %1632 = fmul contract float %1594, %1631
  %1633 = fmul contract float %1632, %1625
  %1634 = fmul contract float %1596, %1631
  %1635 = fmul contract float %1634, %1625
  %1636 = fmul contract float %1598, %1631
  %1637 = fmul contract float %1636, %1625
  %1638 = fadd contract float %1582, %1633
  %1639 = fadd contract float %1583, %1635
  %1640 = fadd contract float %1584, %1637
  br label %1641

1641:                                             ; preds = %1590, %1581
  %1642 = phi float [ %1638, %1590 ], [ %1582, %1581 ]
  %1643 = phi float [ %1639, %1590 ], [ %1583, %1581 ]
  %1644 = phi float [ %1640, %1590 ], [ %1584, %1581 ]
  %1645 = or i32 %144, 25
  %1646 = add i32 %1645, %53
  %1647 = icmp ne i32 %1646, %17
  %1648 = icmp slt i32 %1646, 4096
  %1649 = and i1 %1647, %1648
  br i1 %1649, label %1650, label %1701

1650:                                             ; preds = %1641
  %1651 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1645, i32 0, i32 0, i32 0
  %1652 = load <4 x float>, <4 x float> addrspace(3)* %1651, align 16
  %1653 = extractelement <4 x float> %1652, i64 0
  %1654 = fsub contract float %1653, %20
  %1655 = extractelement <4 x float> %1652, i64 1
  %1656 = fsub contract float %1655, %22
  %1657 = extractelement <4 x float> %1652, i64 2
  %1658 = fsub contract float %1657, %24
  %1659 = fmul contract float %1654, %1654
  %1660 = fmul contract float %1656, %1656
  %1661 = fadd contract float %1659, %1660
  %1662 = fmul contract float %1658, %1658
  %1663 = fadd contract float %1662, %1661
  %1664 = fcmp olt float %1663, 0x39F0000000000000
  %1665 = select i1 %1664, float 0x41F0000000000000, float 1.000000e+00
  %1666 = fmul float %1663, %1665
  %1667 = tail call float @llvm.sqrt.f32(float %1666)
  %1668 = bitcast float %1667 to i32
  %1669 = add nsw i32 %1668, -1
  %1670 = bitcast i32 %1669 to float
  %1671 = add nsw i32 %1668, 1
  %1672 = bitcast i32 %1671 to float
  %1673 = tail call i1 @llvm.amdgcn.class.f32(float %1666, i32 608)
  %1674 = select i1 %1664, float 0x3EF0000000000000, float 1.000000e+00
  %1675 = fneg float %1672
  %1676 = tail call float @llvm.fma.f32(float %1675, float %1667, float %1666)
  %1677 = fcmp ogt float %1676, 0.000000e+00
  %1678 = fneg float %1670
  %1679 = tail call float @llvm.fma.f32(float %1678, float %1667, float %1666)
  %1680 = fcmp ole float %1679, 0.000000e+00
  %1681 = select i1 %1680, float %1670, float %1667
  %1682 = select i1 %1677, float %1672, float %1681
  %1683 = fmul float %1674, %1682
  %1684 = select i1 %1673, float %1666, float %1683
  %1685 = fdiv contract float 1.000000e+00, %1684
  %1686 = extractelement <4 x float> %1652, i64 3
  %1687 = fpext float %1686 to double
  %1688 = fmul contract double %38, %1687
  %1689 = fpext float %1663 to double
  %1690 = fdiv contract double %1688, %1689
  %1691 = fptrunc double %1690 to float
  %1692 = fmul contract float %1654, %1691
  %1693 = fmul contract float %1692, %1685
  %1694 = fmul contract float %1656, %1691
  %1695 = fmul contract float %1694, %1685
  %1696 = fmul contract float %1658, %1691
  %1697 = fmul contract float %1696, %1685
  %1698 = fadd contract float %1642, %1693
  %1699 = fadd contract float %1643, %1695
  %1700 = fadd contract float %1644, %1697
  br label %1701

1701:                                             ; preds = %1650, %1641
  %1702 = phi float [ %1698, %1650 ], [ %1642, %1641 ]
  %1703 = phi float [ %1699, %1650 ], [ %1643, %1641 ]
  %1704 = phi float [ %1700, %1650 ], [ %1644, %1641 ]
  %1705 = or i32 %144, 26
  %1706 = add i32 %1705, %53
  %1707 = icmp ne i32 %1706, %17
  %1708 = icmp slt i32 %1706, 4096
  %1709 = and i1 %1707, %1708
  br i1 %1709, label %1710, label %1761

1710:                                             ; preds = %1701
  %1711 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1705, i32 0, i32 0, i32 0
  %1712 = load <4 x float>, <4 x float> addrspace(3)* %1711, align 16
  %1713 = extractelement <4 x float> %1712, i64 0
  %1714 = fsub contract float %1713, %20
  %1715 = extractelement <4 x float> %1712, i64 1
  %1716 = fsub contract float %1715, %22
  %1717 = extractelement <4 x float> %1712, i64 2
  %1718 = fsub contract float %1717, %24
  %1719 = fmul contract float %1714, %1714
  %1720 = fmul contract float %1716, %1716
  %1721 = fadd contract float %1719, %1720
  %1722 = fmul contract float %1718, %1718
  %1723 = fadd contract float %1722, %1721
  %1724 = fcmp olt float %1723, 0x39F0000000000000
  %1725 = select i1 %1724, float 0x41F0000000000000, float 1.000000e+00
  %1726 = fmul float %1723, %1725
  %1727 = tail call float @llvm.sqrt.f32(float %1726)
  %1728 = bitcast float %1727 to i32
  %1729 = add nsw i32 %1728, -1
  %1730 = bitcast i32 %1729 to float
  %1731 = add nsw i32 %1728, 1
  %1732 = bitcast i32 %1731 to float
  %1733 = tail call i1 @llvm.amdgcn.class.f32(float %1726, i32 608)
  %1734 = select i1 %1724, float 0x3EF0000000000000, float 1.000000e+00
  %1735 = fneg float %1732
  %1736 = tail call float @llvm.fma.f32(float %1735, float %1727, float %1726)
  %1737 = fcmp ogt float %1736, 0.000000e+00
  %1738 = fneg float %1730
  %1739 = tail call float @llvm.fma.f32(float %1738, float %1727, float %1726)
  %1740 = fcmp ole float %1739, 0.000000e+00
  %1741 = select i1 %1740, float %1730, float %1727
  %1742 = select i1 %1737, float %1732, float %1741
  %1743 = fmul float %1734, %1742
  %1744 = select i1 %1733, float %1726, float %1743
  %1745 = fdiv contract float 1.000000e+00, %1744
  %1746 = extractelement <4 x float> %1712, i64 3
  %1747 = fpext float %1746 to double
  %1748 = fmul contract double %38, %1747
  %1749 = fpext float %1723 to double
  %1750 = fdiv contract double %1748, %1749
  %1751 = fptrunc double %1750 to float
  %1752 = fmul contract float %1714, %1751
  %1753 = fmul contract float %1752, %1745
  %1754 = fmul contract float %1716, %1751
  %1755 = fmul contract float %1754, %1745
  %1756 = fmul contract float %1718, %1751
  %1757 = fmul contract float %1756, %1745
  %1758 = fadd contract float %1702, %1753
  %1759 = fadd contract float %1703, %1755
  %1760 = fadd contract float %1704, %1757
  br label %1761

1761:                                             ; preds = %1710, %1701
  %1762 = phi float [ %1758, %1710 ], [ %1702, %1701 ]
  %1763 = phi float [ %1759, %1710 ], [ %1703, %1701 ]
  %1764 = phi float [ %1760, %1710 ], [ %1704, %1701 ]
  %1765 = or i32 %144, 27
  %1766 = add i32 %1765, %53
  %1767 = icmp ne i32 %1766, %17
  %1768 = icmp slt i32 %1766, 4096
  %1769 = and i1 %1767, %1768
  br i1 %1769, label %1770, label %1821

1770:                                             ; preds = %1761
  %1771 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1765, i32 0, i32 0, i32 0
  %1772 = load <4 x float>, <4 x float> addrspace(3)* %1771, align 16
  %1773 = extractelement <4 x float> %1772, i64 0
  %1774 = fsub contract float %1773, %20
  %1775 = extractelement <4 x float> %1772, i64 1
  %1776 = fsub contract float %1775, %22
  %1777 = extractelement <4 x float> %1772, i64 2
  %1778 = fsub contract float %1777, %24
  %1779 = fmul contract float %1774, %1774
  %1780 = fmul contract float %1776, %1776
  %1781 = fadd contract float %1779, %1780
  %1782 = fmul contract float %1778, %1778
  %1783 = fadd contract float %1782, %1781
  %1784 = fcmp olt float %1783, 0x39F0000000000000
  %1785 = select i1 %1784, float 0x41F0000000000000, float 1.000000e+00
  %1786 = fmul float %1783, %1785
  %1787 = tail call float @llvm.sqrt.f32(float %1786)
  %1788 = bitcast float %1787 to i32
  %1789 = add nsw i32 %1788, -1
  %1790 = bitcast i32 %1789 to float
  %1791 = add nsw i32 %1788, 1
  %1792 = bitcast i32 %1791 to float
  %1793 = tail call i1 @llvm.amdgcn.class.f32(float %1786, i32 608)
  %1794 = select i1 %1784, float 0x3EF0000000000000, float 1.000000e+00
  %1795 = fneg float %1792
  %1796 = tail call float @llvm.fma.f32(float %1795, float %1787, float %1786)
  %1797 = fcmp ogt float %1796, 0.000000e+00
  %1798 = fneg float %1790
  %1799 = tail call float @llvm.fma.f32(float %1798, float %1787, float %1786)
  %1800 = fcmp ole float %1799, 0.000000e+00
  %1801 = select i1 %1800, float %1790, float %1787
  %1802 = select i1 %1797, float %1792, float %1801
  %1803 = fmul float %1794, %1802
  %1804 = select i1 %1793, float %1786, float %1803
  %1805 = fdiv contract float 1.000000e+00, %1804
  %1806 = extractelement <4 x float> %1772, i64 3
  %1807 = fpext float %1806 to double
  %1808 = fmul contract double %38, %1807
  %1809 = fpext float %1783 to double
  %1810 = fdiv contract double %1808, %1809
  %1811 = fptrunc double %1810 to float
  %1812 = fmul contract float %1774, %1811
  %1813 = fmul contract float %1812, %1805
  %1814 = fmul contract float %1776, %1811
  %1815 = fmul contract float %1814, %1805
  %1816 = fmul contract float %1778, %1811
  %1817 = fmul contract float %1816, %1805
  %1818 = fadd contract float %1762, %1813
  %1819 = fadd contract float %1763, %1815
  %1820 = fadd contract float %1764, %1817
  br label %1821

1821:                                             ; preds = %1770, %1761
  %1822 = phi float [ %1818, %1770 ], [ %1762, %1761 ]
  %1823 = phi float [ %1819, %1770 ], [ %1763, %1761 ]
  %1824 = phi float [ %1820, %1770 ], [ %1764, %1761 ]
  %1825 = or i32 %144, 28
  %1826 = add i32 %1825, %53
  %1827 = icmp ne i32 %1826, %17
  %1828 = icmp slt i32 %1826, 4096
  %1829 = and i1 %1827, %1828
  br i1 %1829, label %1830, label %1881

1830:                                             ; preds = %1821
  %1831 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1825, i32 0, i32 0, i32 0
  %1832 = load <4 x float>, <4 x float> addrspace(3)* %1831, align 16
  %1833 = extractelement <4 x float> %1832, i64 0
  %1834 = fsub contract float %1833, %20
  %1835 = extractelement <4 x float> %1832, i64 1
  %1836 = fsub contract float %1835, %22
  %1837 = extractelement <4 x float> %1832, i64 2
  %1838 = fsub contract float %1837, %24
  %1839 = fmul contract float %1834, %1834
  %1840 = fmul contract float %1836, %1836
  %1841 = fadd contract float %1839, %1840
  %1842 = fmul contract float %1838, %1838
  %1843 = fadd contract float %1842, %1841
  %1844 = fcmp olt float %1843, 0x39F0000000000000
  %1845 = select i1 %1844, float 0x41F0000000000000, float 1.000000e+00
  %1846 = fmul float %1843, %1845
  %1847 = tail call float @llvm.sqrt.f32(float %1846)
  %1848 = bitcast float %1847 to i32
  %1849 = add nsw i32 %1848, -1
  %1850 = bitcast i32 %1849 to float
  %1851 = add nsw i32 %1848, 1
  %1852 = bitcast i32 %1851 to float
  %1853 = tail call i1 @llvm.amdgcn.class.f32(float %1846, i32 608)
  %1854 = select i1 %1844, float 0x3EF0000000000000, float 1.000000e+00
  %1855 = fneg float %1852
  %1856 = tail call float @llvm.fma.f32(float %1855, float %1847, float %1846)
  %1857 = fcmp ogt float %1856, 0.000000e+00
  %1858 = fneg float %1850
  %1859 = tail call float @llvm.fma.f32(float %1858, float %1847, float %1846)
  %1860 = fcmp ole float %1859, 0.000000e+00
  %1861 = select i1 %1860, float %1850, float %1847
  %1862 = select i1 %1857, float %1852, float %1861
  %1863 = fmul float %1854, %1862
  %1864 = select i1 %1853, float %1846, float %1863
  %1865 = fdiv contract float 1.000000e+00, %1864
  %1866 = extractelement <4 x float> %1832, i64 3
  %1867 = fpext float %1866 to double
  %1868 = fmul contract double %38, %1867
  %1869 = fpext float %1843 to double
  %1870 = fdiv contract double %1868, %1869
  %1871 = fptrunc double %1870 to float
  %1872 = fmul contract float %1834, %1871
  %1873 = fmul contract float %1872, %1865
  %1874 = fmul contract float %1836, %1871
  %1875 = fmul contract float %1874, %1865
  %1876 = fmul contract float %1838, %1871
  %1877 = fmul contract float %1876, %1865
  %1878 = fadd contract float %1822, %1873
  %1879 = fadd contract float %1823, %1875
  %1880 = fadd contract float %1824, %1877
  br label %1881

1881:                                             ; preds = %1830, %1821
  %1882 = phi float [ %1878, %1830 ], [ %1822, %1821 ]
  %1883 = phi float [ %1879, %1830 ], [ %1823, %1821 ]
  %1884 = phi float [ %1880, %1830 ], [ %1824, %1821 ]
  %1885 = or i32 %144, 29
  %1886 = add i32 %1885, %53
  %1887 = icmp ne i32 %1886, %17
  %1888 = icmp slt i32 %1886, 4096
  %1889 = and i1 %1887, %1888
  br i1 %1889, label %1890, label %1941

1890:                                             ; preds = %1881
  %1891 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1885, i32 0, i32 0, i32 0
  %1892 = load <4 x float>, <4 x float> addrspace(3)* %1891, align 16
  %1893 = extractelement <4 x float> %1892, i64 0
  %1894 = fsub contract float %1893, %20
  %1895 = extractelement <4 x float> %1892, i64 1
  %1896 = fsub contract float %1895, %22
  %1897 = extractelement <4 x float> %1892, i64 2
  %1898 = fsub contract float %1897, %24
  %1899 = fmul contract float %1894, %1894
  %1900 = fmul contract float %1896, %1896
  %1901 = fadd contract float %1899, %1900
  %1902 = fmul contract float %1898, %1898
  %1903 = fadd contract float %1902, %1901
  %1904 = fcmp olt float %1903, 0x39F0000000000000
  %1905 = select i1 %1904, float 0x41F0000000000000, float 1.000000e+00
  %1906 = fmul float %1903, %1905
  %1907 = tail call float @llvm.sqrt.f32(float %1906)
  %1908 = bitcast float %1907 to i32
  %1909 = add nsw i32 %1908, -1
  %1910 = bitcast i32 %1909 to float
  %1911 = add nsw i32 %1908, 1
  %1912 = bitcast i32 %1911 to float
  %1913 = tail call i1 @llvm.amdgcn.class.f32(float %1906, i32 608)
  %1914 = select i1 %1904, float 0x3EF0000000000000, float 1.000000e+00
  %1915 = fneg float %1912
  %1916 = tail call float @llvm.fma.f32(float %1915, float %1907, float %1906)
  %1917 = fcmp ogt float %1916, 0.000000e+00
  %1918 = fneg float %1910
  %1919 = tail call float @llvm.fma.f32(float %1918, float %1907, float %1906)
  %1920 = fcmp ole float %1919, 0.000000e+00
  %1921 = select i1 %1920, float %1910, float %1907
  %1922 = select i1 %1917, float %1912, float %1921
  %1923 = fmul float %1914, %1922
  %1924 = select i1 %1913, float %1906, float %1923
  %1925 = fdiv contract float 1.000000e+00, %1924
  %1926 = extractelement <4 x float> %1892, i64 3
  %1927 = fpext float %1926 to double
  %1928 = fmul contract double %38, %1927
  %1929 = fpext float %1903 to double
  %1930 = fdiv contract double %1928, %1929
  %1931 = fptrunc double %1930 to float
  %1932 = fmul contract float %1894, %1931
  %1933 = fmul contract float %1932, %1925
  %1934 = fmul contract float %1896, %1931
  %1935 = fmul contract float %1934, %1925
  %1936 = fmul contract float %1898, %1931
  %1937 = fmul contract float %1936, %1925
  %1938 = fadd contract float %1882, %1933
  %1939 = fadd contract float %1883, %1935
  %1940 = fadd contract float %1884, %1937
  br label %1941

1941:                                             ; preds = %1890, %1881
  %1942 = phi float [ %1938, %1890 ], [ %1882, %1881 ]
  %1943 = phi float [ %1939, %1890 ], [ %1883, %1881 ]
  %1944 = phi float [ %1940, %1890 ], [ %1884, %1881 ]
  %1945 = or i32 %144, 30
  %1946 = add i32 %1945, %53
  %1947 = icmp ne i32 %1946, %17
  %1948 = icmp slt i32 %1946, 4096
  %1949 = and i1 %1947, %1948
  br i1 %1949, label %1950, label %2001

1950:                                             ; preds = %1941
  %1951 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %1945, i32 0, i32 0, i32 0
  %1952 = load <4 x float>, <4 x float> addrspace(3)* %1951, align 16
  %1953 = extractelement <4 x float> %1952, i64 0
  %1954 = fsub contract float %1953, %20
  %1955 = extractelement <4 x float> %1952, i64 1
  %1956 = fsub contract float %1955, %22
  %1957 = extractelement <4 x float> %1952, i64 2
  %1958 = fsub contract float %1957, %24
  %1959 = fmul contract float %1954, %1954
  %1960 = fmul contract float %1956, %1956
  %1961 = fadd contract float %1959, %1960
  %1962 = fmul contract float %1958, %1958
  %1963 = fadd contract float %1962, %1961
  %1964 = fcmp olt float %1963, 0x39F0000000000000
  %1965 = select i1 %1964, float 0x41F0000000000000, float 1.000000e+00
  %1966 = fmul float %1963, %1965
  %1967 = tail call float @llvm.sqrt.f32(float %1966)
  %1968 = bitcast float %1967 to i32
  %1969 = add nsw i32 %1968, -1
  %1970 = bitcast i32 %1969 to float
  %1971 = add nsw i32 %1968, 1
  %1972 = bitcast i32 %1971 to float
  %1973 = tail call i1 @llvm.amdgcn.class.f32(float %1966, i32 608)
  %1974 = select i1 %1964, float 0x3EF0000000000000, float 1.000000e+00
  %1975 = fneg float %1972
  %1976 = tail call float @llvm.fma.f32(float %1975, float %1967, float %1966)
  %1977 = fcmp ogt float %1976, 0.000000e+00
  %1978 = fneg float %1970
  %1979 = tail call float @llvm.fma.f32(float %1978, float %1967, float %1966)
  %1980 = fcmp ole float %1979, 0.000000e+00
  %1981 = select i1 %1980, float %1970, float %1967
  %1982 = select i1 %1977, float %1972, float %1981
  %1983 = fmul float %1974, %1982
  %1984 = select i1 %1973, float %1966, float %1983
  %1985 = fdiv contract float 1.000000e+00, %1984
  %1986 = extractelement <4 x float> %1952, i64 3
  %1987 = fpext float %1986 to double
  %1988 = fmul contract double %38, %1987
  %1989 = fpext float %1963 to double
  %1990 = fdiv contract double %1988, %1989
  %1991 = fptrunc double %1990 to float
  %1992 = fmul contract float %1954, %1991
  %1993 = fmul contract float %1992, %1985
  %1994 = fmul contract float %1956, %1991
  %1995 = fmul contract float %1994, %1985
  %1996 = fmul contract float %1958, %1991
  %1997 = fmul contract float %1996, %1985
  %1998 = fadd contract float %1942, %1993
  %1999 = fadd contract float %1943, %1995
  %2000 = fadd contract float %1944, %1997
  br label %2001

2001:                                             ; preds = %1950, %1941
  %2002 = phi float [ %1998, %1950 ], [ %1942, %1941 ]
  %2003 = phi float [ %1999, %1950 ], [ %1943, %1941 ]
  %2004 = phi float [ %2000, %1950 ], [ %1944, %1941 ]
  %2005 = or i32 %144, 31
  %2006 = add i32 %2005, %53
  %2007 = icmp ne i32 %2006, %17
  %2008 = icmp slt i32 %2006, 4096
  %2009 = and i1 %2007, %2008
  br i1 %2009, label %2010, label %2061

2010:                                             ; preds = %2001
  %2011 = getelementptr inbounds [256 x %struct.HIP_vector_type.0], [256 x %struct.HIP_vector_type.0] addrspace(3)* @_ZZ9getForcesP15HIP_vector_typeIfLj4EEPS_IfLj3EEiiE5shPos, i32 0, i32 %2005, i32 0, i32 0, i32 0
  %2012 = load <4 x float>, <4 x float> addrspace(3)* %2011, align 16
  %2013 = extractelement <4 x float> %2012, i64 0
  %2014 = fsub contract float %2013, %20
  %2015 = extractelement <4 x float> %2012, i64 1
  %2016 = fsub contract float %2015, %22
  %2017 = extractelement <4 x float> %2012, i64 2
  %2018 = fsub contract float %2017, %24
  %2019 = fmul contract float %2014, %2014
  %2020 = fmul contract float %2016, %2016
  %2021 = fadd contract float %2019, %2020
  %2022 = fmul contract float %2018, %2018
  %2023 = fadd contract float %2022, %2021
  %2024 = fcmp olt float %2023, 0x39F0000000000000
  %2025 = select i1 %2024, float 0x41F0000000000000, float 1.000000e+00
  %2026 = fmul float %2023, %2025
  %2027 = tail call float @llvm.sqrt.f32(float %2026)
  %2028 = bitcast float %2027 to i32
  %2029 = add nsw i32 %2028, -1
  %2030 = bitcast i32 %2029 to float
  %2031 = add nsw i32 %2028, 1
  %2032 = bitcast i32 %2031 to float
  %2033 = tail call i1 @llvm.amdgcn.class.f32(float %2026, i32 608)
  %2034 = select i1 %2024, float 0x3EF0000000000000, float 1.000000e+00
  %2035 = fneg float %2032
  %2036 = tail call float @llvm.fma.f32(float %2035, float %2027, float %2026)
  %2037 = fcmp ogt float %2036, 0.000000e+00
  %2038 = fneg float %2030
  %2039 = tail call float @llvm.fma.f32(float %2038, float %2027, float %2026)
  %2040 = fcmp ole float %2039, 0.000000e+00
  %2041 = select i1 %2040, float %2030, float %2027
  %2042 = select i1 %2037, float %2032, float %2041
  %2043 = fmul float %2034, %2042
  %2044 = select i1 %2033, float %2026, float %2043
  %2045 = fdiv contract float 1.000000e+00, %2044
  %2046 = extractelement <4 x float> %2012, i64 3
  %2047 = fpext float %2046 to double
  %2048 = fmul contract double %38, %2047
  %2049 = fpext float %2023 to double
  %2050 = fdiv contract double %2048, %2049
  %2051 = fptrunc double %2050 to float
  %2052 = fmul contract float %2014, %2051
  %2053 = fmul contract float %2052, %2045
  %2054 = fmul contract float %2016, %2051
  %2055 = fmul contract float %2054, %2045
  %2056 = fmul contract float %2018, %2051
  %2057 = fmul contract float %2056, %2045
  %2058 = fadd contract float %2002, %2053
  %2059 = fadd contract float %2003, %2055
  %2060 = fadd contract float %2004, %2057
  br label %2061

2061:                                             ; preds = %2010, %2001
  %2062 = phi float [ %2058, %2010 ], [ %2002, %2001 ]
  %2063 = phi float [ %2059, %2010 ], [ %2003, %2001 ]
  %2064 = phi float [ %2060, %2010 ], [ %2004, %2001 ]
  %2065 = add nuw nsw i32 %144, 32
  %2066 = add i32 %145, 32
  %2067 = icmp eq i32 %2066, %41
  br i1 %2067, label %58, label %140, !llvm.loop !23

2068:                                             ; preds = %43
  %2069 = sext i32 %16 to i64
  %2070 = getelementptr inbounds %struct.HIP_vector_type, %struct.HIP_vector_type addrspace(1)* %1, i64 %2069, i32 0, i32 0, i32 0, i32 0, i64 0
  store float %44, float addrspace(1)* %2070, align 4, !tbaa !16
  %2071 = getelementptr inbounds %struct.HIP_vector_type, %struct.HIP_vector_type addrspace(1)* %1, i64 %2069, i32 0, i32 0, i32 0, i32 0, i64 1
  store float %45, float addrspace(1)* %2071, align 4, !tbaa !16
  %2072 = getelementptr inbounds %struct.HIP_vector_type, %struct.HIP_vector_type addrspace(1)* %1, i64 %2069, i32 0, i32 0, i32 0, i32 0, i64 2
  store float %46, float addrspace(1)* %2072, align 4, !tbaa !16
  br label %2073

2073:                                             ; preds = %2068, %43
  ret void
}

; Function Attrs: convergent mustprogress nounwind willreturn
declare void @llvm.amdgcn.s.barrier() #1

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.sqrt.f32(float) #2

; Function Attrs: mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn
declare float @llvm.fma.f32(float, float, float) #2

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i1 @llvm.amdgcn.class.f32(float, i32) #3

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare align 4 i8 addrspace(4)* @llvm.amdgcn.dispatch.ptr() #3

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.amdgcn.workitem.id.x() #3

; Function Attrs: mustprogress nofree nosync nounwind readnone speculatable willreturn
declare i32 @llvm.amdgcn.workgroup.id.x() #3

; Function Attrs: argmemonly nocallback nofree nounwind willreturn
declare void @llvm.memcpy.p3i8.p1i8.i64(i8 addrspace(3)* noalias nocapture writeonly, i8 addrspace(1)* noalias nocapture readonly, i64, i1 immarg) #4

attributes #0 = { convergent mustprogress norecurse nounwind "amdgpu-flat-work-group-size"="1,256" "frame-pointer"="none" "min-legal-vector-width"="128" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="gfx906" "target-features"="+16-bit-insts,+ci-insts,+dl-insts,+dot1-insts,+dot2-insts,+dot7-insts,+dpp,+flat-address-space,+gfx8-insts,+gfx9-insts,+s-memrealtime,+s-memtime-inst,+sramecc" "uniform-work-group-size"="true" }
attributes #1 = { convergent mustprogress nounwind willreturn }
attributes #2 = { mustprogress nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #3 = { mustprogress nofree nosync nounwind readnone speculatable willreturn }
attributes #4 = { argmemonly nocallback nofree nounwind willreturn }

!llvm.module.flags = !{!0, !1}
!opencl.ocl.version = !{!2}
!llvm.ident = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 7, !"PIC Level", i32 1}
!2 = !{i32 2, i32 0}
!3 = !{!"clang version 15.0.0 (http://10.15.3.7/dcutoolkit/driverruntime/llvm-project.git 340750feeda88c9c2ce8ad481b11d9aa7f033d39)"}
!4 = !{i32 0, i32 1024}
!5 = !{i16 1, i16 1025}
!6 = !{}
!7 = !{!8, !12, i64 12}
!8 = !{!"hsa_kernel_dispatch_packet_s", !9, i64 0, !9, i64 2, !9, i64 4, !9, i64 6, !9, i64 8, !9, i64 10, !12, i64 12, !12, i64 16, !12, i64 20, !12, i64 24, !12, i64 28, !13, i64 32, !14, i64 40, !13, i64 48, !15, i64 56}
!9 = !{!"short", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C/C++ TBAA"}
!12 = !{!"int", !10, i64 0}
!13 = !{!"long", !10, i64 0}
!14 = !{!"any pointer", !10, i64 0}
!15 = !{!"hsa_signal_s", !13, i64 0}
!16 = !{!17, !17, i64 0}
!17 = !{!"omnipotent char", !18, i64 0}
!18 = !{!"Simple C++ TBAA"}
!19 = distinct !{!19, !20}
!20 = !{!"llvm.loop.unroll.disable"}
!21 = distinct !{!21, !22}
!22 = !{!"llvm.loop.mustprogress"}
!23 = distinct !{!23, !22, !20}
