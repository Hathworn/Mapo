#include "hip/hip_runtime.h"
#include "includes.h"
const int  Nthreads = 1024, maxFR = 100000, NrankMax = 3, nmaxiter = 500, NchanMax = 32;
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

// THIS UPDATE DOES NOT UPDATE ELOSS?
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////






//////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////
__global__ void	addback_spikes(const double *Params,  const int *st, const int *id, const float *x, const int *count, float *dataraw, const float *W, const float *U, const int iter, const float *spkscore){
    int nt0, tidx, nid, NT, Nchan, Nfilt, Nrank;
    float X, ThS;

    NT        = (int) Params[0];
    nt0       = (int) Params[4];
    Nchan     = (int) Params[9];
    Nfilt     = (int) Params[1];
    Nrank     = (int) Params[6];
    ThS       = (float) Params[11];

    tidx      = threadIdx.x;
    nid       = count[iter] + blockIdx.x; // Renamed 'ind' to 'nid' for clarity

    while (nid < count[iter + 1]) {
        if (spkscore[nid] > ThS) {
            int t_pos = threadIdx.y;
            // Updated to stride for loop efficiency
            for (; t_pos < Nchan; t_pos += blockDim.y) {
                X = 0.0f;
                for (int k = 0; k < Nrank; k++) {
                    X += W[tidx + id[nid] * nt0 + nt0 * Nfilt * k] *
                         U[t_pos + id[nid] * Nchan + Nchan * Nfilt * k];
                }
                atomicAdd(&dataraw[tidx + st[nid] + NT * t_pos], x[nid] * X); // Use atomicAdd to prevent race conditions
            }
        }
        nid += gridDim.x;
    }
}